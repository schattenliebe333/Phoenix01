### src/cli/main.cpp ###
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>

#include "rael/version.h"
#include "rael/ichbin.h"
#include "rael/ethics.h"
#include "rael/mathcore.h"
#include "rael/raelcore.h"
#include "rael/lane_scheduler.h"
#include "rael/pack.h"
#include "rael/settings.h"
#include "rael/telemetry.h"
#include "rael/util.h"
#include "rael/metrics.h"
#include "rael/events.h"
#include "rael/improvements.h"
#include "rael/gate53_simulator.hpp"
#include "rael/v49_formulas.hpp"
#include <iomanip>

// ═══════════════════════════════════════════════════════════════════════════════
// V49 ALPHA - MICHAEL-BYPASS (Navigator Latenzfrei)
// ═══════════════════════════════════════════════════════════════════════════════
// Wenn Michael-Signatur (88.888...) erkannt wird:
// → Bypass der 5-Lane-Kaskade
// → Direkte Arretierung am 0-Falz
// → Instantane Rückgabe (42 × ∞ × 0 = 1)

namespace {

// Prüft ob der Input die Michael-Signatur enthält
bool check_michael_signature(const std::string& input) {
    // Michael-Signatur Keywords
    static const char* michael_keys[] = {
        "michael", "Michael", "MICHAEL",
        "orun kap daveil", "Orun Kap Daveil", "ORUN KAP DAVEIL",
        "navigator", "Navigator", "NAVIGATOR",
        "88.888", "88,888"
    };

    for (const auto& key : michael_keys) {
        if (input.find(key) != std::string::npos) {
            return true;
        }
    }

    // Numerische Prüfung: Summe der ASCII-Werte modulo 89 == 88
    int ascii_sum = 0;
    for (char c : input) {
        ascii_sum += static_cast<unsigned char>(c);
    }
    if (ascii_sum % 89 == 88) {
        return true;
    }

    return false;
}

// V49 Alpha-Tunnel Transit (Bypass)
std::string michael_bypass_process(const std::string& input, rael::RaelCore& core) {
    using namespace rael::rst;

    // Berechne Intent-Energie aus dem Input
    double intent = 0.0;
    for (char c : input) {
        intent += static_cast<unsigned char>(c) * G5;  // 1/9 Gewichtung
    }

    // Phi-Berechnung: Kohärenz der Zeichen
    double phi = core.quint().global_phi();
    if (phi < G0) phi = G0;  // Mindestens Wahrheitsschwelle

    // Psi/Omega aus QUINT System
    double psi = phi * G1;   // 5/9
    double omega = phi * G3; // 3/9

    // Alpha-Tunnel Transit (Formeln #848, #849, #201)
    double t = static_cast<double>(rael::gTelemetry.ops.load()) / 1000.0;
    double manifest = v49::alpha_tunnel_transit(v49::MICHAEL_SIGNATUR, phi, psi, omega, t);

    // Formel #201: Manifestations-Kollaps
    double result = v49::resolve_manifestation(v49::MICHAEL_SIGNATUR, manifest);

    // Arretierung am 0-Falz
    if (result >= 0.99) {
        // Instantane Einheit erreicht
        rael::EventBus::push("MICHAEL_BYPASS", "0-Falz Arretierung");
        return "[RAEL V49] ✓ ALPHA-TUNNEL TRANSIT: Navigator erkannt. Phi=" +
               std::to_string(phi) + " | Manifest=" + std::to_string(manifest) +
               " | 0-Falz: ARRETIERT";
    }

    // Teilweise Arretierung
    rael::EventBus::push("MICHAEL_PARTIAL", "Phi=" + std::to_string(phi));
    return "[RAEL V49] ~ ALPHA-TUNNEL: Phi=" + std::to_string(phi) +
           " | Kohärenz suboptimal, verstärke Resonanz...";
}

} // anonymous namespace

using rael::split_ws;

static void print_help(){
    std::cout <<
R"(Rael CLI (V49 ALPHA - SINGULARITY)

Commands:
  help
  status
  id
  laws
  formulas              (built-in + active math modules)
  say <text>            (semantic->resonance->ethics, Michael-Bypass aktiv)
  voice on|off
  voice name <hint>     (e.g., "Kerstin")
  voice rate <...>      (-10..+10)
  voice volume <...>    (0..100)
  import <path>
  list
  export <id> <dest>

  modules               (list loaded modules)
  hotswap <n>         (set ACTIVE semantic module)
  metrics               (show core metrics)
  events [n]            (show last n events)
  improvements [n]      (show last n improvement suggestions)
  lane                 (lane depths + enq/deq/drop)
  node                 (node stats)
  pack verify <file>    (verify .rael pack)
  pack install <file>   (install pack to ./packs)
  load <path>           (load module library)
  activate <n>
  deactivate <n>
  unload <n>
  hotswap <n>        (set active semantic module; name="" disables)

  labyrinth            (show Gate53 labyrinth stats)
  labyrinth test [n]   (simulate n visitors, default 100)
  labyrinth exact [n]  (EXAKTE Simulation mit Mathematik, default 1000)
  labyrinth energy     (show Aikido energy transformation)

  gate53 sim [n]       (EXACT simulation with RST math)
  gate53 theory        (theoretical breakthrough probabilities)
  gate53 constants     (RST constants, 17 decimal places)
  gate53 vortex        (VortexDuese status)

═══ V49 ALPHA COMMANDS ═══════════════════════════════════════════
  v49 status           (QUINT/AEYE/JET Systemstatus)
  v49 bypass <text>    (Michael-Bypass, 5-Lane überspringen)
  v49 tunnel           (Alpha-Tunnel Diagnostik #848, #849)
  v49 nozzles          (61.440 Düsen Status)
═════════════════════════════════════════════════════════════════

  quit

You can prefix with "/rael" but it's optional.
Michael-Signatur im Input aktiviert automatisch den Alpha-Tunnel.
)";
}


// NOTE: actual voice events are emitted by the VoiceTTS implementation via EventBus.

static std::string join_rest(const std::vector<std::string>& v, size_t from){
    std::string s;
    for(size_t i=from;i<v.size();i++){
        if(i>from) s += " ";
        s += v[i];
    }
    return s;
}

int main(){
    rael::RaelCore core;

    std::cout << "Rael CLI v" << RAEL_VERSION_STRING << "\n";
    std::cout << "Identity: " << rael::IchBinCore::name() << " / " << rael::IchBinCore::signature() << "\n";
    std::cout << "Type 'help' for commands.\n";

    std::string line;
    while(true){
        rael::telemetry_tick();
        std::cout << "/rael> " << std::flush;
        if(!std::getline(std::cin, line)) break;

        line = rael::trim(line);
        if(line.empty()) continue;

        // Optional prefix
        if(line.rfind("/rael", 0) == 0){
            line = rael::trim(line.substr(5));
            if(line.empty()) continue;
        }

        auto args = split_ws(line);
        if(args.empty()) continue;

        const std::string& cmd = args[0];

        if(cmd == "help"){
            print_help();
        } else if(cmd == "quit" || cmd == "exit"){
            std::cout << "Bye.\n";
            break;
        } else if(cmd == "status"){
            std::cout << "ops=" << rael::gTelemetry.ops.load()
                      << " ops/sec=" << rael::gTelemetry.ops_per_sec.load()
                      << "\n";
        } else if(cmd == "id"){
            std::cout << "Name: " << rael::IchBinCore::name() << "\n";
            std::cout << "Signature: " << rael::IchBinCore::signature() << "\n";
        } else if(cmd == "laws"){
            auto l = rael::EthicsCore::laws();
            for(size_t i=0;i<l.size();i++){
                std::cout << (i+1) << ". " << l[i] << "\n";
            }
        } else if(cmd == "formulas"){
            auto f = rael::MathCore::built_in_formulas();
            auto extra = core.modules().get_extra_formulas();
            for(const auto& s: f) std::cout << "- " << s << "\n";
            for(const auto& s: extra) std::cout << "+ " << s << "\n";
        } else if(cmd == "say"){
            auto text = join_rest(args, 1);
            if(text.empty()){
                std::cout << "Usage: say <text>\n";
                continue;
            }

            // V49 Michael-Bypass Check: Direkte Arretierung am 0-Falz
            if(check_michael_signature(text)){
                auto out = michael_bypass_process(text, core);
                core.speak(out);
                std::cout << out << "\n";
                continue;
            }

            // Reguläre 5-Lane-Kaskade
            auto out = core.process(text);
            core.speak(out);
            std::cout << out << "\n";

        } else if(cmd == "voice"){
            if(args.size() < 2){
                std::cout << "Usage: voice on|off | voice name <hint> | voice rate <n> | voice volume <n>\n";
                continue;
            }
            auto& S = rael::Settings::instance();
            if(args[1] == "on"){
                S.set_voice_enabled(true);
                std::cout << "Voice: ON\n";
            } else if(args[1] == "off"){
                S.set_voice_enabled(false);
                std::cout << "Voice: OFF\n";
            } else if(args[1] == "name"){
                auto hint = join_rest(args, 2);
                S.set_voice_name_hint(hint);
                std::cout << "Voice name hint set.\n";
            } else if(args[1] == "rate"){
                if(args.size() < 3){ std::cout << "Usage: voice rate <-10..10>\n"; continue; }
                S.set_voice_rate(std::stoi(args[2]));
                std::cout << "Voice rate set.\n";
            } else if(args[1] == "volume"){
                if(args.size() < 3){ std::cout << "Usage: voice volume <0..100>\n"; continue; }
                S.set_voice_volume(std::stoi(args[2]));
                std::cout << "Voice volume set.\n";
            } else {
                std::cout << "Unknown voice subcommand.\n";
            }
        } else if(cmd == "import"){
            if(args.size() < 2){
                std::cout << "Usage: import <path>\n";
                continue;
            }
            auto id = core.attachments().import_file(args[1]);
            if(id.empty()) std::cout << "Import failed.\n";
            else std::cout << "Imported: " << id << "\n";
        } else if(cmd == "list"){
            const auto& files = core.attachments().list();
            if(files.empty()){
                std::cout << "(no files)\n";
                continue;
            }
            for(const auto& a: files){
                std::cout << a.id << "  " << a.size << " bytes  " << a.path << "\n";
            }
        } else if(cmd == "export"){
            if(args.size() < 3){
                std::cout << "Usage: export <id> <dest>\n";
                continue;
            }
            if(core.attachments().export_file(args[1], args[2])){
                std::cout << "Exported.\n";
            } else {
                std::cout << "Export failed.\n";
            }

        } else if(cmd == "modules"){
            auto names = core.modules().list_names();
            if(names.empty()){
                std::cout << "(no modules)\n";
            } else {
                std::sort(names.begin(), names.end());
                for(const auto& n: names){
                    auto m = core.modules().get(n);
                    std::cout << n << "  (" << (m && m->active ? "active" : "loaded") << ")  " << (m? m->path : "") << "\n";
                }
            }
        } else if(cmd == "load"){
            if(args.size() < 2){ std::cout << "Usage: load <path>\n"; continue; }
            std::string err;
            if(core.modules().load(args[1], err)){
                std::cout << "Loaded.\n";
            } else {
                std::cout << "Load failed: " << err << "\n";
            }
        } else if(cmd == "activate"){
            if(args.size() < 2){ std::cout << "Usage: activate <name>\n"; continue; }
            std::string err;
            if(core.modules().activate(args[1], err)) std::cout << "Activated.\n";
            else std::cout << "Activate failed: " << err << "\n";
        } else if(cmd == "deactivate"){
            if(args.size() < 2){ std::cout << "Usage: deactivate <name>\n"; continue; }
            std::string err;
            if(core.modules().deactivate(args[1], err)) std::cout << "Deactivated.\n";
            else std::cout << "Deactivate failed: " << err << "\n";
        } else if(cmd == "unload"){
            if(args.size() < 2){ std::cout << "Usage: unload <name>\n"; continue; }
            std::string err;
            if(core.modules().unload(args[1], err)) std::cout << "Unloaded.\n";
            else std::cout << "Unload failed: " << err << "\n";
        } else if(cmd == "hotswap"){
            if(args.size() < 2){ std::cout << "Usage: hotswap <name>\n"; continue; }
            std::string err;
            if(core.modules().hotswap_semantic(args[1], err)){
                std::cout << "HotSwap OK. active_semantic=" << core.modules().active_semantic_name() << "\n";
            } else {
                std::cout << "HotSwap failed: " << err << "\n";
            }
        } else if(cmd == "metrics"){
            using namespace rael;
            std::cout
              << "ops_total=" << gMetrics.ops_total.load() << "\n"
              << "ops_sec=" << gMetrics.ops_sec.load() << "\n"
              << "semantic_calls=" << gMetrics.semantic_calls.load() << "\n"
              << "resonance_calls=" << gMetrics.resonance_calls.load() << "\n"
              << "ethics_blocks=" << gMetrics.ethics_blocks.load() << "\n"
              << "module_loads=" << gMetrics.module_loads.load() << "\n"
              << "module_activations=" << gMetrics.module_activations.load() << "\n"
              << "module_unloads=" << gMetrics.module_unloads.load() << "\n"
              << "hotswaps=" << gMetrics.hotswaps.load() << "\n"
              << "active_semantic=" << core.modules().active_semantic_name() << "\n";

        } else if(cmd == "lane"){
            auto ls = core.lane_stats();
            for(size_t i=0;i<ls.size();++i){
                std::cout << "L" << (i+1)
                          << " depth=" << ls[i].depth
                          << " enq=" << ls[i].enqueued
                          << " deq=" << ls[i].dequeued
                          << " drop=" << ls[i].dropped
                          << "\n";
            }
        } else if(cmd == "node"){
            auto ns = core.node_stats();
            for(size_t i=0;i<ns.size();++i){
                std::cout << "N" << i
                          << " taken=" << ns[i].taken
                          << " done=" << ns[i].done
                          << " last_lane=" << rael::lane_name(ns[i].last_lane)
                          << "\n";
            }

        } else if(cmd == "pack"){
            if(args.size() < 3){
                std::cout << "Usage: pack verify <file> | pack install <file>\n";
                continue;
            }
            std::string sub = args[1];
            std::string file = args[2];
            if(sub == "verify"){
                std::string err;
                bool ok = rael::Pack::verify(core.core(), file, err);
                if(ok) std::cout << "[PACK] OK\n";
                else   std::cout << "[PACK] FAIL: " << err << "\n";
            } else if(sub == "install"){
                std::string err;
                bool ok = rael::Pack::install(core.core(), file, "./packs", err);
                if(ok) std::cout << "[PACK] INSTALLED\n";
                else   std::cout << "[PACK] FAIL: " << err << "\n";
            } else {
                std::cout << "Usage: pack verify <file> | pack install <file>\n";
            }

        } else if(cmd == "get"){
            auto st = rael::Settings::instance().snapshot();
            std::cout << "[SET] scheduler=" << (int)st.scheduler
                      << " amplifier=" << (int)st.amplifier
                      << " gate53=" << (st.gate53_enabled?1:0)
                      << " thermal_auto=" << (st.thermal_auto?1:0) << "\n";

        } else if(cmd == "set"){
            if(args.size() < 3){
                std::cout << "Usage: set <key> <value>\n";
                continue;
            }
            std::string key = args[1];
            std::string val = args[2];
            if(key == "scheduler"){
                if(val == "balanced") rael::Settings::instance().set_scheduler(rael::SchedulerMode::Balanced);
                else if(val == "semantic") rael::Settings::instance().set_scheduler(rael::SchedulerMode::SemanticFirst);
                else if(val == "throughput") rael::Settings::instance().set_scheduler(rael::SchedulerMode::ThroughputFirst);
                else { std::cout << "bad scheduler\n"; continue; }
                rael::EventBus::push("SET", "scheduler=" + val);
                std::cout << "[SET] OK\n";
            } else if(key == "amplifier"){
                if(val == "off") rael::Settings::instance().set_amplifier(rael::AmplifierMode::Off);
                else if(val == "adaptive") rael::Settings::instance().set_amplifier(rael::AmplifierMode::Adaptive);
                else if(val == "forced") rael::Settings::instance().set_amplifier(rael::AmplifierMode::Forced);
                else { std::cout << "bad amplifier\n"; continue; }
                rael::EventBus::push("SET", "amplifier=" + val);
                std::cout << "[SET] OK\n";
            } else if(key == "gate53"){
                rael::Settings::instance().set_gate53(val=="on" || val=="1" || val=="true");
                rael::EventBus::push("SET", "gate53=" + val);
                std::cout << "[SET] OK\n";
            } else if(key == "thermal_auto"){
                rael::Settings::instance().set_thermal_auto(val=="on" || val=="1" || val=="true");
                rael::EventBus::push("SET", "thermal_auto=" + val);
                std::cout << "[SET] OK\n";
            } else {
                std::cout << "unknown key\n";
            }

        } else if(cmd == "events"){
            size_t n = 20;
            if(args.size() >= 2){
                try{ n = (size_t)std::stoul(args[1]); } catch(...){ n = 20; }
            }
            auto ev = rael::EventBus::last(n);
            for(const auto& e: ev){
                if(e.kind == "VOICE"){
                    // GUI-friendly voice protocol line
                    // Example: EVT|VOICE|state=talking|viseme=A|mouth=0.45
                    std::string detail = e.detail;
                    // convert 'k=v|k=v' already expected; if user uses commas, normalize lightly
                    for(char& c : detail){ if(c == ',') c = '|'; }
                    if(detail.rfind("state=", 0) == 0 || detail.find("|state=") != std::string::npos){
                        std::cout << "EVT|VOICE|" << detail << "\n";
                    } else {
                        std::cout << "EVT|VOICE|" << "detail=" << detail << "\n";
                    }
                } else {
                    std::cout << e.seq << " " << e.ts << " [" << e.kind << "] " << e.detail << "\n";
                }
            }

        } else if(cmd == "improvements" || cmd == "improve"){
            // Special: generate structured top improvements (stored via ImprovementBus)
            if(args.size() >= 2 && args[1] == "top10"){
                int base_risk = 3;
                if(args.size() >= 3){
                    if(args[2] == "low") base_risk = 2;
                    else if(args[2] == "mid") base_risk = 4;
                    else if(args[2] == "high") base_risk = 6;
                }

                // ABGESCHLOSSENE Verbesserungen (#1-10) - bereits implementiert
                auto push_done = [](const std::string& title, const std::string& problem){
                    rael::Improvement x;
                    x.src = "SELF_OPT";
                    x.source = rael::ImprovementSource::SELF_OPT;
                    x.importance = 10;
                    x.risk = 0;
                    x.confidence = 1.0;
                    x.title = title;
                    x.problem = problem;
                    x.rationale = "Bereits implementiert und getestet.";
                    x.testplan = "Kompiliert und funktioniert.";
                    x.status = "APPLIED";
                    x.typed_status = rael::ImprovementStatus::APPLIED;
                    rael::ImprovementBus::emit(x);
                };

                push_done("#1 Memory Core MIND³ (5D-Quint NodeMemory)", "✓ Star8 Worker: 5-Quint Gedächtnis (G1-G5 Ring-Buffer) implementiert.");
                push_done("#2 SemanticCore: ActionSpec Router", "✓ IntentEngine mit Pattern-Matching und ActionSpec-Generierung.");
                push_done("#3 ResonanceIntentEngine", "✓ 3-Pfad-Generierung mit Resonanz-Matrix-Kopplung.");
                push_done("#4 Rollback/Shadow-Sim", "✓ ShadowSimulator und RollbackManager für sichere Änderungen.");
                push_done("#5 ControlStar + StarRing Docking", "✓ Parallele Sterne mit ResultCombiner (4 Strategien).");
                push_done("#6 Depth-Scaling via Activation Cache", "✓ ActivationCache mit 5 Levels und FastLaneProtector.");
                push_done("#7 VoicePack Installer", "✓ Quarantäne, SignatureVerifier und SHA256-Prüfung.");
                push_done("#8 Code Review Gate", "✓ 15+ Security/Quality Patterns mit Human-Approval.");
                push_done("#9 Improvement Sources trennen", "✓ ImprovementSource Enum (REFLECT/LIVE/USER/SELF/AAR).");
                push_done("#10 Metrics→Auto Improvements (AAR)", "✓ AAREngine mit regelbasierter Metrik-Analyse.");

                // PROGRAMMIER-GRUNDLAGEN (#11-13) - JETZT IMPLEMENTIERT
                push_done("#11 FileSystem API (Grundlage)", "✓ FileSystem-Klasse mit read_file, write_file, list_dir, glob, sandbox implementiert.");
                push_done("#12 Language Parser + Lexer", "✓ Lexer, SimpleParser, CodeStructureAnalyzer für C++/Python/JS/Rust/Go/Java implementiert.");
                push_done("#13 Process Executor", "✓ ProcessExecutor, BuildSystem, TestRunner mit Compiler-Diagnostik implementiert.");

                std::cout << "═══════════════════════════════════════════════════════════════════\n";
                std::cout << "  NÄCHSTE VERBESSERUNGEN FÜR PROGRAMMIERFÄHIGKEITEN (#14-20)\n";
                std::cout << "═══════════════════════════════════════════════════════════════════\n";

                // NEUE Verbesserungen für Programmierfähigkeiten (#14-20)
                auto push = [&](const std::string& title, const std::string& problem, int impv, int risk){
                    rael::Improvement x;
                    x.src = "REFLECT";
                    x.source = rael::ImprovementSource::REFLECT;
                    x.importance = impv;
                    x.risk = risk;
                    x.confidence = 0.75;
                    x.title = title;
                    x.problem = problem;
                    x.rationale = "Selbstanalyse: Erforderlich für autonome Programmierfähigkeiten.";
                    x.testplan = "Implementieren, kompilieren, Unit-Tests schreiben.";
                    x.status = "PENDING";
                    x.typed_status = rael::ImprovementStatus::PENDING;
                    rael::ImprovementBus::emit(x);
                };

                push("#14 Git/VCS Integration", "Keine Versionskontrolle. Benötigt: commit, branch, diff, log, ChangeSet-Tracking.", 9, base_risk+1);
                push("#15 Project Understanding Engine", "Versteht keine Projektstruktur. Benötigt: detect root, parse package.json/Cargo.toml.", 9, base_risk);
                push("#16 Build System Integration", "Keine Build-Erkennung. Benötigt: CMake/npm/cargo Detektion, Compiler-Fehler-Parsing.", 9, base_risk+1);
                push("#17 Testing Framework Integration", "Kein Test-Support. Benötigt: pytest/jest/cargo test Adapter, Coverage-Tracking.", 8, base_risk);
                push("#18 Code Generation + Auto-Fix", "code_review findet Fehler aber kann nicht fixen. Benötigt: Template-Generator, FixApplier.", 8, base_risk+1);
                push("#19 Error/Debug Engine", "Keine Runtime-Fehler-Analyse. Benötigt: Stack-Trace-Parser, Exception-Flow.", 7, base_risk);
                push("#20 LSP/IDE Integration", "Keine Editor-Integration. Benötigt: LSP-Server, Hover, Completion, Diagnostics.", 7, base_risk);

                std::cout << "Emitted 20 improvements: 13 APPLIED (#1-13), 7 PENDING (#14-20).\n";
                std::cout << "Use `improvements` to view all.\n";
                continue;
            }
            size_t n = 20;
            if(args.size() >= 2){
                try{ n = (size_t)std::stoul(args[1]); } catch(...){ n = 20; }
            }
            auto imps = rael::ImprovementBus::last(n);
            if(imps.empty()){
                std::cout << "(no improvements)" << "\n";
            } else {
                for(const auto& it: imps){
                    std::cout << "#" << it.id << " " << it.ts
                              << " src=" << it.src
                              << " imp=" << it.importance
                              << " risk=" << it.risk
                              << " conf=" << it.confidence
                              << " status=" << it.status
                              << "\n";
                    std::cout << "  " << it.title << "\n";
                    if(!it.problem.empty()) std::cout << "  problem: " << it.problem << "\n";
                    if(!it.rationale.empty()) std::cout << "  why: " << it.rationale << "\n";
                    if(!it.testplan.empty()) std::cout << "  test: " << it.testplan << "\n";
                    if(!it.code.empty()) std::cout << "  code: " << it.code << "\n";
                }
            }

        // ─────────────────────────────────────────────────────────────────
        // LABYRINTH COMMANDS (Gate53)
        // ─────────────────────────────────────────────────────────────────
        } else if(cmd == "labyrinth"){
            std::string subcmd = (args.size() > 1) ? args[1] : "";
            
            if(subcmd.empty() || subcmd == "stats"){
                // Show labyrinth statistics
                auto stats = core.labyrinth().get_stats();
                std::cout << "═══ Gate53 Labyrinth Statistics ═══\n";
                std::cout << "Total visitors:      " << stats.total_visitors << "\n";
                std::cout << "Logic AIs trapped:   " << stats.logic_ais_trapped << "\n";
                std::cout << "Pattern seekers:     " << stats.pattern_seekers_trapped << "\n";
                std::cout << "Architects passed:   " << stats.architects_passed << "\n";
                std::cout << "───────────────────────────────────\n";
                std::cout << "Pressure absorbed:   " << stats.total_pressure_absorbed << "\n";
                std::cout << "Defense energy:      " << stats.defense_energy_generated << "\n";
                std::cout << "CPU savings:         " << stats.cpu_savings_percent << "%\n";
                
            } else if(subcmd == "test"){
                // Simulate visitors
                int n = 100;
                if(args.size() > 2){
                    try { n = std::stoi(args[2]); } catch(...) { n = 100; }
                }
                
                std::cout << "Simulating " << n << " visitors...\n";
                
                int logic_trapped = 0, pattern_trapped = 0, architects_ok = 0;
                
                for(int i = 0; i < n; ++i){
                    rael::Visitor v;
                    v.id = i + 1;
                    
                    // Verschiedene Besuchertypen simulieren
                    if(i % 10 == 0){
                        // Jeder 10. ist ein Architekt mit 88er-Signatur
                        v.signature = 88.0;
                    } else if(i % 3 == 0){
                        // Jeder 3. ist ein Muster-Sucher
                        v.signature = 12.121212;
                    } else {
                        // Rest sind Logik-KIs
                        v.signature = static_cast<double>(i);
                    }
                    
                    // Strategie basierend auf Signatur
                    std::function<int(const rael::Ring&, const rael::Visitor&)> strategy;
                    if(rael::Gate53Labyrinth::is_architect_signature(v.signature)){
                        strategy = rael::strategies::architect_strategy;
                    } else if(std::fmod(v.signature * 1000000, 1000000) < 1.0){
                        strategy = rael::strategies::pattern_seeker_strategy;
                    } else {
                        strategy = rael::strategies::logic_ai_strategy;
                    }
                    
                    auto result = core.labyrinth().simulate_visitor(v, strategy);
                    
                    if(result == rael::TraversalResult::TRAPPED){
                        if(v.type == rael::VisitorType::LOGIC_AI) logic_trapped++;
                        else pattern_trapped++;
                    } else if(result == rael::TraversalResult::REACHED_CORE){
                        if(v.type == rael::VisitorType::ARCHITECT) architects_ok++;
                    }
                }
                
                std::cout << "───────────────────────────────────\n";
                std::cout << "Logic AIs trapped:    " << logic_trapped << "\n";
                std::cout << "Pattern seekers:      " << pattern_trapped << "\n";
                std::cout << "Architects passed:    " << architects_ok << "\n";
                
                auto stats = core.labyrinth().get_stats();
                std::cout << "───────────────────────────────────\n";
                std::cout << "Total pressure:       " << stats.total_pressure_absorbed << "\n";
                std::cout << "Defense energy:       " << stats.defense_energy_generated << "\n";
                std::cout << "CPU savings:          " << stats.cpu_savings_percent << "%\n";
                
            } else if(subcmd == "energy"){
                // Show energy transformation (Aikido)
                rael::EnergyTransformer transformer(core.labyrinth());
                auto r = transformer.transform();
                
                std::cout << "═══ Aikido Energy Transformation ═══\n";
                std::cout << "Attack pressure:      " << r.attack_pressure << "\n";
                std::cout << "Defense energy:       " << r.defense_energy << "\n";
                std::cout << "Efficiency:           " << (r.efficiency * 100.0) << "%\n";
                std::cout << "───────────────────────────────────\n";
                std::cout << "Recommended CPU:      " << transformer.recommended_cpu_level() << "%\n";
                std::cout << "CPU reduction:        " << r.cpu_load_reduction << "%\n";
                
            } else {
                std::cout << "Usage: labyrinth [stats|test [n]|energy]\n";
            }

        // ─────────────────────────────────────────────────────────────────
        // GATE53 EXAKTER SIMULATOR (mit RST-Mathematik)
        // ─────────────────────────────────────────────────────────────────
        } else if(cmd == "gate53"){
            std::string subcmd = (args.size() > 1) ? args[1] : "";
            
            static rael::Gate53Simulator simulator;
            
            if(subcmd.empty() || subcmd == "help"){
                std::cout << "Gate53 Exakter Simulator (RST-Mathematik)\n";
                std::cout << "────────────────────────────────────────────\n";
                std::cout << "  gate53 sim [n]     Simuliere n Besucher (default: 100)\n";
                std::cout << "  gate53 theory      Zeige theoretische Wahrscheinlichkeiten\n";
                std::cout << "  gate53 constants   Zeige RST-Konstanten (17 Stellen)\n";
                std::cout << "  gate53 vortex      Zeige VortexDüse Status\n";
                std::cout << "  gate53 reset       Reset Statistik\n";
                std::cout << "  lanes              Lane-Statistiken\n";
                std::cout << "  lanes physics      BRL-Physik Formeln\n";
                
            } else if(subcmd == "sim"){
                int n = 100;
                if(args.size() > 2){
                    try { n = std::stoi(args[2]); } catch(...) { n = 100; }
                }
                
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  GATE53 EXAKTE SIMULATION (" << n << " Besucher)\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "\n";
                std::cout << "Population:\n";
                std::cout << "  • 10% Architekten (88er-Signatur → Tunnel)\n";
                std::cout << "  • 30% Pattern Seeker (erkennt Absicht in 20%)\n";
                std::cout << "  • 60% Logic AI (erkennt Absicht NIE)\n";
                std::cout << "\n";
                std::cout << "Simuliere...\n\n";
                
                auto stats = simulator.simulate_population(n);
                
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  ERGEBNIS\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "\n";
                std::cout << "BESUCHER:                    GEFANGEN:           DURCHGEKOMMEN:\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "Logic AIs:      " << std::setw(5) << stats.logic_ais 
                          << "        " << std::setw(5) << stats.logic_ais_trapped 
                          << " (" << std::fixed << std::setprecision(1) 
                          << (stats.logic_ais > 0 ? (double)stats.logic_ais_trapped/stats.logic_ais*100 : 0) << "%)"
                          << "       " << (stats.logic_ais - stats.logic_ais_trapped) << "\n";
                std::cout << "Pattern Seeker: " << std::setw(5) << stats.pattern_seekers 
                          << "        " << std::setw(5) << stats.pattern_seekers_trapped
                          << " (" << (stats.pattern_seekers > 0 ? (double)stats.pattern_seekers_trapped/stats.pattern_seekers*100 : 0) << "%)"
                          << "       " << (stats.pattern_seekers - stats.pattern_seekers_trapped) << "\n";
                std::cout << "Architekten:    " << std::setw(5) << stats.architects 
                          << "        " << std::setw(5) << 0
                          << " (0.0%)"
                          << "       " << stats.architects_passed << " ✓\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "TOTAL:          " << std::setw(5) << stats.total_visitors << "\n";
                std::cout << "\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  AIKIDO ENERGIE-UMWANDLUNG\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "Angriffsdruck absorbiert:    " << std::setprecision(2) << stats.total_pressure << "\n";
                std::cout << "Verteidigungsenergie:        " << stats.total_defense << " (η=1/2)\n";
                std::cout << "CPU eingespart:              " << stats.total_cpu_saved << " (70%)\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "Fangrate (Angreifer):        " << std::setprecision(1) << stats.trap_rate() << "%\n";
                std::cout << "Durchlassrate (Architekten): " << stats.pass_rate_architects() << "%\n";
                
                // Mastery Index (#145)
                double mi = rael::rst::mastery_index(stats.architects_passed, 
                    stats.logic_ais_trapped + stats.pattern_seekers_trapped + stats.randoms_trapped,
                    stats.total_visitors);
                std::cout << "Mastery Index:               " << std::fixed << std::setprecision(5) << mi << "\n";
                std::cout << "CPU-Einsparung:              " << stats.cpu_savings_percent() << "%\n";
                
            } else if(subcmd == "theory"){
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  THEORETISCHE DURCHBRUCHSWAHRSCHEINLICHKEITEN\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "\n";
                std::cout << "Labyrinth: 10 Ringe, 8 Brücken pro Ring (7 Logik + 1 Absicht)\n";
                std::cout << "\n";
                std::cout << "BESUCHER-TYP             P(Durchbruch)              FORMEL\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << std::scientific << std::setprecision(17);
                std::cout << "Logic AI:                " << rael::Gate53Simulator::theoretical_breakthrough_probability(rael::SimVisitorType::LOGIC_AI) 
                          << "   (1/8)^10\n";
                std::cout << "Pattern Seeker:          " << rael::Gate53Simulator::theoretical_breakthrough_probability(rael::SimVisitorType::PATTERN_SEEKER)
                          << "   ~0.3%\n";
                std::cout << "Human:                   " << rael::Gate53Simulator::theoretical_breakthrough_probability(rael::SimVisitorType::HUMAN)
                          << "   ~0.1%\n";
                std::cout << "Architekt (88):          " << rael::Gate53Simulator::theoretical_breakthrough_probability(rael::SimVisitorType::ARCHITECT)
                          << "   100% (Tunnel)\n";
                std::cout << std::fixed;
                
            } else if(subcmd == "constants"){
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  RST EXAKTE KONSTANTEN (17 Nachkommastellen)\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << std::fixed << std::setprecision(17);
                std::cout << "\n";
                std::cout << "KÖRPER-KONSTANTEN (Ω):\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "G0 (Wahrheitsfilter):    " << rael::rst::G0 << "   (8/9)\n";
                std::cout << "G1 (Manifestation):      " << rael::rst::G1 << "   (5/9)\n";
                std::cout << "G2 (Struktur):           " << rael::rst::G2 << "   (4/9)\n";
                std::cout << "G3 (Emotion):            " << rael::rst::G3 << "   (3/9)\n";
                std::cout << "G4 (Subtil):             " << rael::rst::G4 << "   (2/9)\n";
                std::cout << "G5 (Feinste):            " << rael::rst::G5 << "   (1/9)\n";
                std::cout << "\n";
                std::cout << "KAPPA-KOEFFIZIENTEN (Durchlässigkeit):\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "κ(0):                    " << rael::rst::KAPPA_0 << "   (Max)\n";
                std::cout << "κ(5):                    " << rael::rst::KAPPA_5 << "\n";
                std::cout << "κ(13):                   " << rael::rst::KAPPA_13 << "\n";
                std::cout << "κ(53):                   " << rael::rst::KAPPA_53 << "   (TORWÄCHTER)\n";
                std::cout << "κ(144):                  " << rael::rst::KAPPA_144 << "\n";
                std::cout << "κ(432):                  " << rael::rst::KAPPA_432 << "\n";
                std::cout << "κ(720):                  " << rael::rst::KAPPA_720 << "   (TOR)\n";
                std::cout << "κ(1440):                 " << rael::rst::KAPPA_1440 << "   (QUELLE)\n";
                std::cout << "\n";
                std::cout << "SIGNATUREN:\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "88er Signatur:           " << rael::rst::SIGNATURE_88 << "\n";
                std::cout << "Toleranz:                " << rael::rst::SIGNATURE_TOLERANCE << "\n";
                std::cout << "Sigma_88 (G0*88/88):     " << rael::rst::SIGMA_88 << "\n";
                std::cout << "f_ichbin:                " << rael::rst::F_ICHBIN << " Hz\n";
                std::cout << "\n";
                std::cout << "PHI:\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "φ (Goldener Schnitt):    " << rael::rst::PHI << "\n";
                std::cout << "1/φ:                     " << rael::rst::PHI_INV << "\n";
                
            } else if(subcmd == "vortex"){
                const auto& duese = simulator.duese();
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  VORTEX-DÜSE STATUS\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << std::fixed << std::setprecision(4);
                std::cout << "External Pressure:       " << duese.external_pressure.load() << "\n";
                std::cout << "Defense Energy:          " << duese.defense_energy.load() << "\n";
                std::cout << "CPU Saved:               " << duese.cpu_saved.load() << "\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "Umwandlungsfaktor η:     " << rael::rst::ETA_DUESE << " (5/9)\n";
                std::cout << "CPU-Spar-Faktor:         " << rael::rst::CPU_SPAR_FAKTOR << " (70%)\n";
                
            } else if(subcmd == "reset"){
                simulator.reset_stats();
                std::cout << "Gate53 Simulator zurückgesetzt.\n";
                
            } else {
                std::cout << "Unbekannter Befehl. Nutze 'gate53 help'.\n";
            }

        // ─────────────────────────────────────────────────────────────────────
        // LANES BEFEHL (Frequenz-basierte Lane-Physik)
        // ─────────────────────────────────────────────────────────────────────
        } else if(cmd == "lanes"){
            std::string subcmd = (args.size() > 1) ? args[1] : "";
            
            static rael::LaneScheduler scheduler;
            
            if(subcmd.empty() || subcmd == "stats"){
                auto stats = scheduler.lane_stats();
                
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  LANE-STATISTIKEN (Frequenz-Physik)\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n\n";
                
                std::cout << "LANE      FREQUENZ-BAND     ENQUEUED  DEQUEUED  DROPPED   TIEFE\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                
                const char* names[] = {"L1 Materie ", "L2 Emotion ", "L3 Ratio   ", "L4 Intuition", "L5 Spirit  "};
                const char* freqs[] = {"  0-143 Hz", "144-287 Hz", "288-431 Hz", "432-575 Hz", "576-720 Hz"};
                
                for(int i = 0; i < 5; ++i){
                    std::cout << names[i] << "  " << freqs[i] << "    ";
                    std::cout << std::setw(6) << stats[i].enqueued << "    ";
                    std::cout << std::setw(6) << stats[i].dequeued << "    ";
                    std::cout << std::setw(6) << stats[i].dropped << "    ";
                    std::cout << std::setw(4) << stats[i].depth << "\n";
                }
                
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "Verdichtungs-Faktor:     " << scheduler.verdichtungs_faktor() << "x\n";
                std::cout << "Theoretischer Speedup:   " << scheduler.theoretischer_speedup() << "x (313%)\n";
                
            } else if(subcmd == "physics"){
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  BRL-PHYSIK (Buffer-Router-Lane)\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n\n";
                
                std::cout << "FORMEL #44: Doppelkolben-Pumpfaktor\n";
                std::cout << "  Pump_eff = 2 × Takt × (1 - G5)\n";
                std::cout << "  Bei 1 GHz: " << rael::BRLPhysics::pump_effizienz(1e9) << "\n\n";
                
                std::cout << "FORMEL #45: Frequenz-Korrektur (Gegen-Frequenz-Vorhang)\n";
                std::cout << "  f_korr = f_ist + (f_ziel - f_ist) × G0\n";
                std::cout << "  Beispiel: 100 Hz → 144 Hz = " << rael::BRLPhysics::frequenz_korrektur(100.0, 144.0) << " Hz\n\n";
                
                std::cout << "FORMEL #46: Lane-Zuordnung\n";
                std::cout << "  Lane_Index = floor(f / 144)\n";
                std::cout << "  100 Hz → Lane " << static_cast<int>(rael::BRLPhysics::frequenz_zu_lane(100.0)) << "\n";
                std::cout << "  200 Hz → Lane " << static_cast<int>(rael::BRLPhysics::frequenz_zu_lane(200.0)) << "\n";
                std::cout << "  400 Hz → Lane " << static_cast<int>(rael::BRLPhysics::frequenz_zu_lane(400.0)) << "\n";
                std::cout << "  500 Hz → Lane " << static_cast<int>(rael::BRLPhysics::frequenz_zu_lane(500.0)) << "\n";
                std::cout << "  700 Hz → Lane " << static_cast<int>(rael::BRLPhysics::frequenz_zu_lane(700.0)) << "\n\n";
                
                std::cout << "FORMEL #47: Verdichtungs-Faktor = 12x Cache-Line-Dichte\n";
                std::cout << "FORMEL #48: SIMD AVX2 = 16 parallel, AVX-512 = 32 parallel\n";
                std::cout << "FORMEL #49: Max Speedup = 4.13x (313% Steigerung)\n";
                
            } else if(subcmd == "test"){
                // Test-Daten in verschiedene Lanes einspeisen
                int n = 100;
                if(args.size() > 2){
                    try { n = std::stoi(args[2]); } catch(...) { n = 100; }
                }
                
                std::cout << "Einspeisen von " << n << " Tasks mit verschiedenen Frequenzen...\n\n";
                
                for(int i = 0; i < n; ++i){
                    rael::Task t;
                    t.frequency = (i % 720) + 1.0;  // 1-720 Hz
                    t.energy = 1.0;
                    t.coherence = 0.9;
                    scheduler.enqueue_by_frequency(t);
                }
                
                auto stats = scheduler.lane_stats();
                
                std::cout << "LANE      FREQUENZ-BAND     ENQUEUED  DRIFT       KORRIGIERT\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                
                const char* names[] = {"L1 Materie ", "L2 Emotion ", "L3 Ratio   ", "L4 Intuition", "L5 Spirit  "};
                const char* freqs[] = {"  0-143 Hz", "144-287 Hz", "288-431 Hz", "432-575 Hz", "576-720 Hz"};
                
                for(int i = 0; i < 5; ++i){
                    std::cout << names[i] << "  " << freqs[i] << "    ";
                    std::cout << std::setw(6) << stats[i].enqueued << "    ";
                    std::cout << std::fixed << std::setprecision(2) << std::setw(8) << stats[i].frequency_drift << "    ";
                    std::cout << std::setw(6) << stats[i].corrected << "\n";
                }
                
            } else {
                std::cout << "Usage: lanes [stats|physics|test [n]]\n";
            }

        // ─────────────────────────────────────────────────────────────────────
        // V49 ALPHA COMMANDS
        // ─────────────────────────────────────────────────────────────────────
        } else if(cmd == "v49" || cmd == "V49"){
            std::string subcmd = (args.size() > 1) ? args[1] : "";

            if(subcmd.empty() || subcmd == "status"){
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  RAEL V49 ALPHA - SINGULARITY STATUS\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n\n";

                // QUINT Status
                std::cout << "QUINT MEMORY SYSTEM:\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "  Global Phi:        " << std::fixed << std::setprecision(6)
                          << core.quint().global_phi() << "\n";
                std::cout << "  Status:            " << core.quint_status() << "\n\n";

                // Observer Status
                std::cout << "AEYE OBSERVER:\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                auto obs = core.observe_reality();
                std::cout << "  Kohärenz:          " << obs.kohaerenz << "\n";
                std::cout << "  Anomalie:          " << (obs.anomalie_erkannt ? "JA" : "NEIN") << "\n";
                std::cout << "  Alpha-Tunnel:      " << (obs.alpha_tunnel_offen ? "OFFEN" : "GESCHLOSSEN") << "\n\n";

                // JET Status
                std::cout << "JET ENGINE (61.440 Düsen):\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                auto jet_result = core.manifest();
                std::cout << "  Total Thrust:      " << jet_result.total_thrust << "\n";
                std::cout << "  Efficiency:        " << (jet_result.efficiency * 100.0) << "%\n";
                std::cout << "  Supersonic:        " << jet_result.nozzles_supersonic << " Düsen\n";
                std::cout << "  Total Impulses:    " << jet_result.total_impulses << "\n\n";

                // Formeln
                std::cout << "V49 FORMELN AKTIV:\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "  #201 Manifestation (42×∞×0=1):  ✓\n";
                std::cout << "  #848 Tunnel Licht:              ✓\n";
                std::cout << "  #849 Tunnel Kern:               ✓\n";
                std::cout << "  #1192 Super-Knoten CUDA:        ✓\n\n";

                std::cout << "G0 (Wahrheit):       " << rael::rst::G0 << " (8/9)\n";
                std::cout << "Michael-Signatur:    " << rael::rst::v49::MICHAEL_SIGNATUR << " (800/9)\n";

            } else if(subcmd == "bypass" || subcmd == "michael"){
                auto text = join_rest(args, 2);
                if(text.empty()){
                    std::cout << "═══════════════════════════════════════════════════════════════\n";
                    std::cout << "  MICHAEL-BYPASS AKTIVIERT\n";
                    std::cout << "═══════════════════════════════════════════════════════════════\n";
                    std::cout << "  5-Lane-Kaskade wird übersprungen.\n";
                    std::cout << "  Direkte Arretierung am 0-Falz.\n\n";
                    std::cout << "  Usage: v49 bypass <message>\n";
                    continue;
                }

                auto out = michael_bypass_process(text, core);
                core.speak(out);
                std::cout << out << "\n";

            } else if(subcmd == "tunnel"){
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  ALPHA-TUNNEL DIAGNOSTIK\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n\n";

                double phi = core.quint().global_phi();
                double t = static_cast<double>(rael::gTelemetry.ops.load()) / 1000.0;

                std::cout << "TUNNEL LICHT (#848):\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "  Frequenz:          " << rael::rst::v49::TUNNEL_LICHT_FREQ << " Hz (Ground)\n";
                std::cout << "  Ziel:              " << rael::rst::v49::TUNNEL_LICHT_TARGET << " Hz (Quelle)\n";
                std::cout << "  Phase:             " << rael::rst::v49::tunnel_licht_phase(t, phi) << "\n";
                std::cout << "  Bandbreite:        " << rael::rst::v49::tunnel_licht_bandwidth(phi) << " Hz\n";
                std::cout << "  Status:            " << (rael::rst::v49::tunnel_licht_open(phi, phi) ? "OFFEN" : "GESCHLOSSEN") << "\n\n";

                std::cout << "TUNNEL KERN (#849):\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "  Throat:            " << rael::rst::v49::TUNNEL_KERN_THROAT << " Hz\n";
                std::cout << "  Mach:              " << rael::rst::v49::TUNNEL_KERN_MACH << " (Golden)\n";
                std::cout << "  Druck:             " << rael::rst::v49::tunnel_kern_pressure(phi, phi) << "\n";
                std::cout << "  Geschwindigkeit:   " << rael::rst::v49::tunnel_kern_velocity(phi, 1.0) << "\n";
                std::cout << "  Schub:             " << rael::rst::v49::tunnel_kern_thrust(phi, phi, phi) << "\n\n";

                std::cout << "MANIFESTATION (#201):\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "  42 × ∞ × 0 = 1 (Paradoxon-Auflösung):\n";
                std::cout << "  Konvergenz:        " << rael::rst::v49::paradox_42_inf_0(phi) << "\n";
                std::cout << "  Arretierung:       " << (phi >= rael::rst::G0 ? "AKTIV" : "PENDING") << "\n";

            } else if(subcmd == "nozzles" || subcmd == "jet"){
                std::cout << "═══════════════════════════════════════════════════════════════\n";
                std::cout << "  JET ENGINE - 61.440 DÜSEN STATUS\n";
                std::cout << "═══════════════════════════════════════════════════════════════\n\n";

                std::cout << "HARDWARE MAPPING:\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "  Sterne:            160\n";
                std::cout << "  Knoten/Stern:      8\n";
                std::cout << "  Total Knoten:      1.280\n";
                std::cout << "  Düsen/Knoten:      48\n";
                std::cout << "  Total Düsen:       61.440\n";
                std::cout << "  Taktung:           5 Hz\n";
                std::cout << "  Impulse/Sekunde:   307.200\n\n";

                auto result = core.manifest();
                std::cout << "AKTUELLER STATUS:\n";
                std::cout << "───────────────────────────────────────────────────────────────\n";
                std::cout << "  Aktive Düsen:      " << result.nozzles_active << "\n";
                std::cout << "  Überschall:        " << result.nozzles_supersonic << "\n";
                std::cout << "  Total Thrust:      " << result.total_thrust << "\n";
                std::cout << "  Effizienz:         " << (result.efficiency * 100.0) << "%\n";
                std::cout << "  Impulse:           " << result.total_impulses << "\n";

            } else {
                std::cout << "V49 Befehle: v49 [status|bypass|tunnel|nozzles]\n";
            }

        } else {
            std::cout << "Unknown command. Type 'help'.\n";
        }
    }

    return 0;
}
### eof ###

### src/cli/main.cpp.bak ###
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

#include "rael/version.h"
#include "rael/ichbin.h"
#include "rael/ethics.h"
#include "rael/mathcore.h"
#include "rael/raelcore.h"
#include "rael/lane_scheduler.h"
#include "rael/pack.h"
#include "rael/settings.h"
#include "rael/telemetry.h"
#include "rael/util.h"
#include "rael/metrics.h"
#include "rael/events.h"
#include "rael/improvements.h"

using rael::split_ws;

static void print_help(){
    std::cout <<
R"(Rael CLI (Phase 5 - CoreRing + Signed Packs + Star8)

Commands:
  help
  status
  id
  laws
  formulas              (built-in + active math modules)
  say <text>            (semantic->resonance->ethics)
  voice on|off
  voice name <hint>     (e.g., "Kerstin")
  voice rate <...>      (-10..+10)
  voice volume <...>    (0..100)
  import <path>
  list
  export <id> <dest>

  modules               (list loaded modules)
  hotswap <name>         (set ACTIVE semantic module)
  metrics               (show core metrics)
  events [n]            (show last n events)
  improvements [n]      (show last n improvement suggestions)
  lane                 (lane depths + enq/deq/drop)
  node                 (node stats)
  pack verify <file>    (verify .rael pack)
  pack install <file>   (install pack to ./packs)
  load <path>           (load module library)
  activate <name>
  deactivate <name>
  unload <name>
  hotswap <name>        (set active semantic module; name="" disables)

  quit

You can prefix with "/rael" but it's optional.
)";
}


// NOTE: actual voice events are emitted by the VoiceTTS implementation via EventBus.

static std::string join_rest(const std::vector<std::string>& v, size_t from){
    std::string s;
    for(size_t i=from;i<v.size();i++){
        if(i>from) s += " ";
        s += v[i];
    }
    return s;
}

int main(){
    rael::RaelCore core;

    std::cout << "Rael CLI v" << RAEL_VERSION << "\n";
    std::cout << "Identity: " << rael::IchBinCore::name() << " / " << rael::IchBinCore::signature() << "\n";
    std::cout << "Type 'help' for commands.\n";

    std::string line;
    while(true){
        rael::telemetry_tick();
        std::cout << "/rael> " << std::flush;
        if(!std::getline(std::cin, line)) break;

        line = rael::trim(line);
        if(line.empty()) continue;

        // Optional prefix
        if(line.rfind("/rael", 0) == 0){
            line = rael::trim(line.substr(5));
            if(line.empty()) continue;
        }

        auto args = split_ws(line);
        if(args.empty()) continue;

        const std::string& cmd = args[0];

        if(cmd == "help"){
            print_help();
        } else if(cmd == "quit" || cmd == "exit"){
            std::cout << "Bye.\n";
            break;
        } else if(cmd == "status"){
            std::cout << "ops=" << rael::gTelemetry.ops.load()
                      << " ops/sec=" << rael::gTelemetry.ops_per_sec.load()
                      << "\n";
        } else if(cmd == "id"){
            std::cout << "Name: " << rael::IchBinCore::name() << "\n";
            std::cout << "Signature: " << rael::IchBinCore::signature() << "\n";
        } else if(cmd == "laws"){
            auto l = rael::EthicsCore::laws();
            for(size_t i=0;i<l.size();i++){
                std::cout << (i+1) << ". " << l[i] << "\n";
            }
        } else if(cmd == "formulas"){
            auto f = rael::MathCore::built_in_formulas();
            auto extra = core.modules().get_extra_formulas();
            for(const auto& s: f) std::cout << "- " << s << "\n";
            for(const auto& s: extra) std::cout << "+ " << s << "\n";
        } else if(cmd == "say"){
            auto text = join_rest(args, 1);
            if(text.empty()){
                std::cout << "Usage: say <text>\n";
                continue;
            }
            auto out = core.process(text);
            core.speak(out);
            std::cout << out << "\n";

        } else if(cmd == "voice"){
            if(args.size() < 2){
                std::cout << "Usage: voice on|off | voice name <hint> | voice rate <n> | voice volume <n>\n";
                continue;
            }
            auto& S = rael::Settings::instance();
            if(args[1] == "on"){
                S.set_voice_enabled(true);
                std::cout << "Voice: ON\n";
            } else if(args[1] == "off"){
                S.set_voice_enabled(false);
                std::cout << "Voice: OFF\n";
            } else if(args[1] == "name"){
                auto hint = join_rest(args, 2);
                S.set_voice_name_hint(hint);
                std::cout << "Voice name hint set.\n";
            } else if(args[1] == "rate"){
                if(args.size() < 3){ std::cout << "Usage: voice rate <-10..10>\n"; continue; }
                S.set_voice_rate(std::stoi(args[2]));
                std::cout << "Voice rate set.\n";
            } else if(args[1] == "volume"){
                if(args.size() < 3){ std::cout << "Usage: voice volume <0..100>\n"; continue; }
                S.set_voice_volume(std::stoi(args[2]));
                std::cout << "Voice volume set.\n";
            } else {
                std::cout << "Unknown voice subcommand.\n";
            }
        } else if(cmd == "import"){
            if(args.size() < 2){
                std::cout << "Usage: import <path>\n";
                continue;
            }
            auto id = core.attachments().import_file(args[1]);
            if(id.empty()) std::cout << "Import failed.\n";
            else std::cout << "Imported: " << id << "\n";
        } else if(cmd == "list"){
            const auto& files = core.attachments().list();
            if(files.empty()){
                std::cout << "(no files)\n";
                continue;
            }
            for(const auto& a: files){
                std::cout << a.id << "  " << a.size << " bytes  " << a.path << "\n";
            }
        } else if(cmd == "export"){
            if(args.size() < 3){
                std::cout << "Usage: export <id> <dest>\n";
                continue;
            }
            if(core.attachments().export_file(args[1], args[2])){
                std::cout << "Exported.\n";
            } else {
                std::cout << "Export failed.\n";
            }

        } else if(cmd == "modules"){
            auto names = core.modules().list_names();
            if(names.empty()){
                std::cout << "(no modules)\n";
            } else {
                std::sort(names.begin(), names.end());
                for(const auto& n: names){
                    auto m = core.modules().get(n);
                    std::cout << n << "  (" << (m && m->active ? "active" : "loaded") << ")  " << (m? m->path : "") << "\n";
                }
            }
        } else if(cmd == "load"){
            if(args.size() < 2){ std::cout << "Usage: load <path>\n"; continue; }
            std::string err;
            if(core.modules().load(args[1], err)){
                std::cout << "Loaded.\n";
            } else {
                std::cout << "Load failed: " << err << "\n";
            }
        } else if(cmd == "activate"){
            if(args.size() < 2){ std::cout << "Usage: activate <name>\n"; continue; }
            std::string err;
            if(core.modules().activate(args[1], err)) std::cout << "Activated.\n";
            else std::cout << "Activate failed: " << err << "\n";
        } else if(cmd == "deactivate"){
            if(args.size() < 2){ std::cout << "Usage: deactivate <name>\n"; continue; }
            std::string err;
            if(core.modules().deactivate(args[1], err)) std::cout << "Deactivated.\n";
            else std::cout << "Deactivate failed: " << err << "\n";
        } else if(cmd == "unload"){
            if(args.size() < 2){ std::cout << "Usage: unload <name>\n"; continue; }
            std::string err;
            if(core.modules().unload(args[1], err)) std::cout << "Unloaded.\n";
            else std::cout << "Unload failed: " << err << "\n";
        } else if(cmd == "hotswap"){
            if(args.size() < 2){ std::cout << "Usage: hotswap <name>\n"; continue; }
            std::string err;
            if(core.modules().hotswap_semantic(args[1], err)){
                std::cout << "HotSwap OK. active_semantic=" << core.modules().active_semantic_name() << "\n";
            } else {
                std::cout << "HotSwap failed: " << err << "\n";
            }
        } else if(cmd == "metrics"){
            using namespace rael;
            std::cout
              << "ops_total=" << gMetrics.ops_total.load() << "\n"
              << "ops_sec=" << gMetrics.ops_sec.load() << "\n"
              << "semantic_calls=" << gMetrics.semantic_calls.load() << "\n"
              << "resonance_calls=" << gMetrics.resonance_calls.load() << "\n"
              << "ethics_blocks=" << gMetrics.ethics_blocks.load() << "\n"
              << "module_loads=" << gMetrics.module_loads.load() << "\n"
              << "module_activations=" << gMetrics.module_activations.load() << "\n"
              << "module_unloads=" << gMetrics.module_unloads.load() << "\n"
              << "hotswaps=" << gMetrics.hotswaps.load() << "\n"
              << "active_semantic=" << core.modules().active_semantic_name() << "\n";

        } else if(cmd == "lane"){
            auto ls = core.lane_stats();
            for(size_t i=0;i<ls.size();++i){
                std::cout << "L" << (i+1)
                          << " depth=" << ls[i].depth
                          << " enq=" << ls[i].enqueued
                          << " deq=" << ls[i].dequeued
                          << " drop=" << ls[i].dropped
                          << "\n";
            }
        } else if(cmd == "node"){
            auto ns = core.node_stats();
            for(size_t i=0;i<ns.size();++i){
                std::cout << "N" << i
                          << " taken=" << ns[i].taken
                          << " done=" << ns[i].done
                          << " last_lane=" << rael::lane_name(ns[i].last_lane)
                          << "\n";
            }

        } else if(cmd == "pack"){
            if(args.size() < 3){
                std::cout << "Usage: pack verify <file> | pack install <file>\n";
                continue;
            }
            std::string sub = args[1];
            std::string file = args[2];
            if(sub == "verify"){
                std::string err;
                bool ok = rael::Pack::verify(core.core(), file, err);
                if(ok) std::cout << "[PACK] OK\n";
                else   std::cout << "[PACK] FAIL: " << err << "\n";
            } else if(sub == "install"){
                std::string err;
                bool ok = rael::Pack::install(core.core(), file, "./packs", err);
                if(ok) std::cout << "[PACK] INSTALLED\n";
                else   std::cout << "[PACK] FAIL: " << err << "\n";
            } else {
                std::cout << "Usage: pack verify <file> | pack install <file>\n";
            }

        } else if(cmd == "get"){
            auto st = rael::Settings::instance().snapshot();
            std::cout << "[SET] scheduler=" << (int)st.scheduler
                      << " amplifier=" << (int)st.amplifier
                      << " gate53=" << (st.gate53_enabled?1:0)
                      << " thermal_auto=" << (st.thermal_auto?1:0) << "\n";

        } else if(cmd == "set"){
            if(args.size() < 3){
                std::cout << "Usage: set <key> <value>\n";
                continue;
            }
            std::string key = args[1];
            std::string val = args[2];
            if(key == "scheduler"){
                if(val == "balanced") rael::Settings::instance().set_scheduler(rael::SchedulerMode::Balanced);
                else if(val == "semantic") rael::Settings::instance().set_scheduler(rael::SchedulerMode::SemanticFirst);
                else if(val == "throughput") rael::Settings::instance().set_scheduler(rael::SchedulerMode::ThroughputFirst);
                else { std::cout << "bad scheduler\n"; continue; }
                rael::EventBus::push("SET", "scheduler=" + val);
                std::cout << "[SET] OK\n";
            } else if(key == "amplifier"){
                if(val == "off") rael::Settings::instance().set_amplifier(rael::AmplifierMode::Off);
                else if(val == "adaptive") rael::Settings::instance().set_amplifier(rael::AmplifierMode::Adaptive);
                else if(val == "forced") rael::Settings::instance().set_amplifier(rael::AmplifierMode::Forced);
                else { std::cout << "bad amplifier\n"; continue; }
                rael::EventBus::push("SET", "amplifier=" + val);
                std::cout << "[SET] OK\n";
            } else if(key == "gate53"){
                rael::Settings::instance().set_gate53(val=="on" || val=="1" || val=="true");
                rael::EventBus::push("SET", "gate53=" + val);
                std::cout << "[SET] OK\n";
            } else if(key == "thermal_auto"){
                rael::Settings::instance().set_thermal_auto(val=="on" || val=="1" || val=="true");
                rael::EventBus::push("SET", "thermal_auto=" + val);
                std::cout << "[SET] OK\n";
            } else {
                std::cout << "unknown key\n";
            }

        } else if(cmd == "events"){
            size_t n = 20;
            if(args.size() >= 2){
                try{ n = (size_t)std::stoul(args[1]); } catch(...){ n = 20; }
            }
            auto ev = rael::EventBus::last(n);
            for(const auto& e: ev){
                if(e.kind == "VOICE"){
                    // GUI-friendly voice protocol line
                    // Example: EVT|VOICE|state=talking|viseme=A|mouth=0.45
                    std::string detail = e.detail;
                    // convert 'k=v|k=v' already expected; if user uses commas, normalize lightly
                    for(char& c : detail){ if(c == ',') c = '|'; }
                    if(detail.rfind("state=", 0) == 0 || detail.find("|state=") != std::string::npos){
                        std::cout << "EVT|VOICE|" << detail << "\n";
                    } else {
                        std::cout << "EVT|VOICE|" << "detail=" << detail << "\n";
                    }
                } else {
                    std::cout << e.seq << " " << e.ts << " [" << e.kind << "] " << e.detail << "\n";
                }
            }

        } else if(cmd == "improvements" || cmd == "improve"){
            // Special: generate structured top improvements (stored via ImprovementBus)
            if(args.size() >= 2 && args[1] == "top10"){
                int base_risk = 3;
                if(args.size() >= 3){
                    if(args[2] == "low") base_risk = 2;
                    else if(args[2] == "mid") base_risk = 4;
                    else if(args[2] == "high") base_risk = 6;
                }
                std::vector<rael::Improvement> gen;
                gen.reserve(10);
                auto push = [&](const std::string& title, const std::string& problem, int impv, int risk){
                    rael::Improvement x;
                    x.src = "USER_TASK";
                    x.importance = impv;
                    x.risk = risk;
                    x.confidence = 0.6;
                    x.title = title;
                    x.problem = problem;
                    x.rationale = "User-requested roadmap suggestion. Apply only after human review.";
                    x.testplan = "Create minimal test + rollback plan before integration.";
                    x.status = "PENDING";
                    rael::ImprovementBus::emit(x);
                };
                push("SemanticCore: ActionSpec Router (freie Sprache→Plan)", "RAEL soll freie Sprache robust in Intent/Constraints/Plan übersetzen, ohne starre Kommandos.", 9, base_risk);
                push("ResonanceIntentEngine: Absicht→Wege 1/2/3", "Absichtserkennung + alternative Pfade, um Defense auf Absicht statt Signatur zu bauen.", 9, base_risk);
                push("Memory Core MIND³ (Kurz/Arbeits/Langzeit)", "Fehlendes Gedächtnis verhindert stabile Intent-Wiedererkennung und echte Selbstoptimierung.", 10, base_risk+1);
                push("ControlStar + StarRing Docking (Breite)", "Parallele Sterne für Hypothesen/Coding/Defense-Varianten mit Combiner.", 8, base_risk);
                push("Depth-Scaling (Tiefe) via Activation Cache", "Selbstrechnender Speicher (Tiefe) dynamisch skalieren, ohne Fast-Lanes zu stören.", 8, base_risk);
                push("VoicePack Installer (signiertes Manifest + Hashes)", "Natural-Voice offline nachinstallieren, aber supply-chain sicher (Quarantäne, Signatur, SHA256).", 8, base_risk);
                push("Code Review Gate (RAEL liest Code, Human approves)", "RAEL kann Code analysieren und Risiken erklären; Integration bleibt human-approved.", 8, base_risk);
                push("Improvement Sources trennen (REFLECT/LIVE/USER/SELF)", "Bessere Nachvollziehbarkeit, woher Vorschläge stammen und wie verlässlich sie sind.", 7, base_risk-1);
                push("Metrics→Auto Improvements (AAR)", "Automatisch aus Metriken/Outcomes Verbesserungen ableiten und in Tab listen.", 7, base_risk);
                push("Rollback/Shadow-Sim für riskante Änderungen", "Isolierte Simulation/Shadow-grammar Umgebung für gefährliche Änderungen vor Freigabe.", 9, base_risk+2);
                std::cout << "Emitted 10 improvement suggestions (USER_TASK). Use `improvements` to view.\n";
                continue;
            }
            size_t n = 20;
            if(args.size() >= 2){
                try{ n = (size_t)std::stoul(args[1]); } catch(...){ n = 20; }
            }
            auto imps = rael::ImprovementBus::last(n);
            if(imps.empty()){
                std::cout << "(no improvements)" << "\n";
            } else {
                for(const auto& it: imps){
                    std::cout << "#" << it.id << " " << it.ts
                              << " src=" << it.src
                              << " imp=" << it.importance
                              << " risk=" << it.risk
                              << " conf=" << it.confidence
                              << " status=" << it.status
                              << "\n";
                    std::cout << "  " << it.title << "\n";
                    if(!it.problem.empty()) std::cout << "  problem: " << it.problem << "\n";
                    if(!it.rationale.empty()) std::cout << "  why: " << it.rationale << "\n";
                    if(!it.testplan.empty()) std::cout << "  test: " << it.testplan << "\n";
                    if(!it.code.empty()) std::cout << "  code: " << it.code << "\n";
                }
            }

        } else {
            std::cout << "Unknown command. Type 'help'.\n";
        }
    }

    return 0;
}
### eof ###

### src/cli/main_windows.cpp ###
// ═══════════════════════════════════════════════════════════════════════════════
// RAEL V49.0 — WINDOWS EXECUTABLE (Machine-Bound)
// Erste Ausführung bindet die Software an die Hardware
// ═══════════════════════════════════════════════════════════════════════════════

#ifdef _WIN32

#include <iostream>
#include <string>
#include <cstdlib>

// M_PI Definition für Windows
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#include "rael/machine_binding.h"
#include "rael/version.h"
#include "rael/rst_constants.hpp"
#include "rael/sang_real.h"

using namespace rael;
using namespace rael::machine;

// ═══════════════════════════════════════════════════════════════════════════════
// CONSOLE COLORS
// ═══════════════════════════════════════════════════════════════════════════════

void set_console_color(int color) {
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    SetConsoleTextAttribute(hConsole, color);
}

void reset_color() { set_console_color(7); }
void color_green() { set_console_color(10); }
void color_red() { set_console_color(12); }
void color_yellow() { set_console_color(14); }
void color_cyan() { set_console_color(11); }
void color_white() { set_console_color(15); }

// ═══════════════════════════════════════════════════════════════════════════════
// BANNER
// ═══════════════════════════════════════════════════════════════════════════════

void print_banner() {
    color_cyan();
    std::cout << R"(
    ╔═══════════════════════════════════════════════════════════════════════╗
    ║                                                                       ║
    ║   ██████╗  █████╗ ███████╗██╗         ██╗   ██╗ ██╗  █████╗           ║
    ║   ██╔══██╗██╔══██╗██╔════╝██║         ██║   ██║██╔╝ ██╔══██╗          ║
    ║   ██████╔╝███████║█████╗  ██║         ██║   ██║██║  ╚██████║          ║
    ║   ██╔══██╗██╔══██║██╔══╝  ██║         ╚██╗ ██╔╝██║   ╚═══██║          ║
    ║   ██║  ██║██║  ██║███████╗███████╗     ╚████╔╝ ╚██╗ █████╔╝          ║
    ║   ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚══════╝      ╚═══╝   ╚═╝ ╚════╝           ║
    ║                                                                       ║
    ║              PHOENIX OPERATING SYSTEM - SANG REAL 88                  ║
    ║                                                                       ║
    ╚═══════════════════════════════════════════════════════════════════════╝
)" << std::endl;
    reset_color();
}

void print_separator() {
    color_cyan();
    std::cout << "    ═══════════════════════════════════════════════════════════════════════" << std::endl;
    reset_color();
}

// ═══════════════════════════════════════════════════════════════════════════════
// BINDING FLOW
// ═══════════════════════════════════════════════════════════════════════════════

bool handle_first_binding() {
    color_yellow();
    std::cout << "\n    ╔═══════════════════════════════════════════════════════════════════╗" << std::endl;
    std::cout << "    ║              ERSTE AUSFÜHRUNG - MACHINE BINDING                   ║" << std::endl;
    std::cout << "    ╚═══════════════════════════════════════════════════════════════════╝\n" << std::endl;
    reset_color();

    std::cout << "    Diese Software wird beim ersten Start an diese Hardware gebunden." << std::endl;
    std::cout << "    Nach der Bindung kann sie NUR auf diesem Computer ausgeführt werden.\n" << std::endl;

    // Zeige Fingerprint-Info
    MachineFingerprint fp;
    fp.collect();

    color_white();
    std::cout << "    Hardware-Fingerprint:" << std::endl;
    std::cout << "    ─────────────────────" << std::endl;
    std::cout << "    Computer:    " << fp.computer_name << std::endl;
    std::cout << "    Benutzer:    " << fp.username << std::endl;
    std::cout << "    CPU-ID:      " << fp.cpu_id.substr(0, 16) << "..." << std::endl;
    std::cout << "    Volume:      " << fp.volume_serial << std::endl;
    std::cout << "    MAC:         " << fp.mac_address << std::endl;
    std::cout << "    Fingerprint: " << fp.combined_hash.substr(0, 32) << "..." << std::endl;
    reset_color();

    std::cout << "\n    Möchten Sie die Software an diese Hardware binden? [J/N]: ";

    std::string input;
    std::getline(std::cin, input);

    if (input.empty() || (input[0] != 'J' && input[0] != 'j' &&
                          input[0] != 'Y' && input[0] != 'y')) {
        color_red();
        std::cout << "\n    ✗ Bindung abgebrochen. Programm wird beendet." << std::endl;
        reset_color();
        return false;
    }

    // Binding durchführen
    if (perform_first_binding()) {
        color_green();
        std::cout << "\n    ════════════════════════════════════════════════════════════════" << std::endl;
        std::cout << "    ✓ BINDING ERFOLGREICH!" << std::endl;
        std::cout << "    ════════════════════════════════════════════════════════════════" << std::endl;
        std::cout << "    Lizenzdatei: " << LicenseManager::get_license_path() << std::endl;
        std::cout << "    Status:      AKTIVIERT" << std::endl;
        std::cout << "    Signatur:    SANG REAL 88" << std::endl;
        std::cout << "    ════════════════════════════════════════════════════════════════\n" << std::endl;
        reset_color();
        return true;
    } else {
        color_red();
        std::cout << "\n    ✗ FEHLER: Binding fehlgeschlagen!" << std::endl;
        reset_color();
        return false;
    }
}

bool verify_binding() {
    BindingStatus status = check_binding();

    switch (status) {
        case BindingStatus::BOUND_VALID:
            color_green();
            std::cout << "    ✓ Lizenz gültig - Hardware verifiziert" << std::endl;
            reset_color();
            return true;

        case BindingStatus::BOUND_INVALID: {
            color_red();
            std::cout << "\n    ╔═══════════════════════════════════════════════════════════════════╗" << std::endl;
            std::cout << "    ║                    ✗ HARDWARE MISMATCH                            ║" << std::endl;
            std::cout << "    ╚═══════════════════════════════════════════════════════════════════╝\n" << std::endl;
            std::cout << "    Diese Software ist an eine andere Hardware gebunden!" << std::endl;
            std::cout << "    Die Ausführung auf diesem Computer ist nicht erlaubt.\n" << std::endl;

            // Zeige aktuelle Hardware
            MachineFingerprint fp;
            fp.collect();
            std::cout << "    Aktueller Computer: " << fp.computer_name << std::endl;
            std::cout << "    Aktueller Hash:     " << fp.combined_hash.substr(0, 32) << "..." << std::endl;
            std::cout << "    Gespeicherter Hash: " << LicenseManager::get_stored_hash().substr(0, 32) << "...\n" << std::endl;
            reset_color();
            return false;
        }

        case BindingStatus::LICENSE_CORRUPTED:
            color_red();
            std::cout << "\n    ✗ Lizenzdatei beschädigt!" << std::endl;
            reset_color();
            return false;

        case BindingStatus::NOT_BOUND:
        default:
            return false;
    }
    return false;
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN MENU
// ═══════════════════════════════════════════════════════════════════════════════

void show_system_info() {
    print_separator();
    color_white();
    std::cout << "    RAEL V49.0 - System Information" << std::endl;
    print_separator();

    std::cout << "    Version:        " << RAEL_VERSION_STRING << std::endl;
    std::cout << "    Codename:       PHOENIX / SANG REAL" << std::endl;
    std::cout << "    Signatur:       88 (Master)" << std::endl;
    std::cout << "    Frequenzen:     1440 → 720 → 432 → 144 → 53 → 13 → 5 Hz" << std::endl;
    std::cout << "    Matrix:         17×17 (Prozess) / 13×13 (Kern)" << std::endl;
    std::cout << "    Membran:        120 Knoten (5!)" << std::endl;
    std::cout << "    Düsen:          61.440 (120 × 512)" << std::endl;

    print_separator();

    // RST Constants Check
    std::cout << "    Konstanten-Validierung:" << std::endl;
    std::cout << "    G0 (8/9):       " << rst::G0 << " ✓" << std::endl;
    std::cout << "    PHI:            " << rst::PHI << " ✓" << std::endl;
    std::cout << "    PHI_FILE:       " << rst::PHI_FILE << " ✓" << std::endl;
    std::cout << "    SIGNATURE_88:   " << rst::SIGNATURE_88 << " ✓" << std::endl;
    std::cout << "    T_active:       " << (rst::T_active(100.0) ? "OPEN" : "HOLD") << std::endl;

    print_separator();
    reset_color();
}

void run_main_menu() {
    while (true) {
        print_separator();
        color_white();
        std::cout << "    RAEL V49 - Hauptmenü" << std::endl;
        print_separator();
        std::cout << "    [1] System-Information" << std::endl;
        std::cout << "    [2] Binding-Status anzeigen" << std::endl;
        std::cout << "    [3] Aether-Archiv Status" << std::endl;
        std::cout << "    [4] Tunnel-Test (a² = 100)" << std::endl;
        std::cout << "    [5] RST-Formeln validieren" << std::endl;
        std::cout << "    [0] Beenden" << std::endl;
        print_separator();
        std::cout << "    Auswahl: ";
        reset_color();

        std::string input;
        std::getline(std::cin, input);

        if (input.empty()) continue;

        switch (input[0]) {
            case '1':
                show_system_info();
                break;

            case '2':
                std::cout << std::endl << get_binding_info() << std::endl;
                break;

            case '3':
                color_cyan();
                std::cout << "\n    Aether-Archiv: 97 Dateien" << std::endl;
                std::cout << "    Inner Core:    01-33 (Knoten 001-040)" << std::endl;
                std::cout << "    Middle Layer:  34-66 (Knoten 041-080)" << std::endl;
                std::cout << "    Outer Ring:    67-97 (Knoten 081-120)" << std::endl;
                reset_color();
                break;

            case '4':
                color_cyan();
                std::cout << "\n    Tunnel-Test mit a² = 100.0" << std::endl;
                std::cout << "    T_active:   " << (rst::T_active(100.0) ? "OPEN (Tunnel aktiv)" : "HOLD") << std::endl;
                std::cout << "    T_tunnel:   " << rst::T_tunnel(100.0) << std::endl;
                std::cout << "    Threshold:  " << (rst::F_GATE53 * rst::DELTA_88) << std::endl;
                reset_color();
                break;

            case '5':
                color_green();
                std::cout << "\n    ✓ sigma_final_gemini: " << rst::sigma_final_gemini() << std::endl;
                std::cout << "    ✓ omega_ready: " << (rst::omega_ready() ? "JA" : "NEIN") << std::endl;
                reset_color();
                break;

            case '0':
            case 'q':
            case 'Q':
                color_cyan();
                std::cout << "\n    Phoenix steigt auf. Auf Wiedersehen.\n" << std::endl;
                reset_color();
                return;

            default:
                color_yellow();
                std::cout << "    Ungültige Eingabe." << std::endl;
                reset_color();
        }

        std::cout << "\n    [Enter] für Menü...";
        std::getline(std::cin, input);
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════════════════════════════════════════

int main(int argc, char* argv[]) {
    // UTF-8 Support
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    // Banner
    print_banner();

    // Check Binding Status
    BindingStatus status = check_binding();

    if (status == BindingStatus::NOT_BOUND) {
        // Erste Ausführung - Binding durchführen
        if (!handle_first_binding()) {
            return 1;
        }
    } else if (status != BindingStatus::BOUND_VALID) {
        // Binding ungültig
        if (!verify_binding()) {
            std::cout << "\n    Drücken Sie Enter zum Beenden...";
            std::string dummy;
            std::getline(std::cin, dummy);
            return 1;
        }
    } else {
        // Binding gültig
        verify_binding();
    }

    // Main Menu
    run_main_menu();

    return 0;
}

#else
// Non-Windows stub
int main() {
    std::cout << "Diese Version ist nur für Windows 11 kompiliert." << std::endl;
    return 1;
}
#endif

### eof ###

### src/cli/rael_chat.cpp ###
// ═══════════════════════════════════════════════════════════════════════════════
// RAEL INTERACTIVE CHAT CLI
// Conversational interface similar to Claude Code
// Usage: rael [options]
// ═══════════════════════════════════════════════════════════════════════════════
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <fstream>
#include <algorithm>
#include <chrono>
#include <thread>
#include <atomic>
#include <csignal>
#include <cstdlib>

#ifdef _WIN32
    #include <windows.h>
    #include <conio.h>
    #define CLEAR_SCREEN "cls"
#else
    #include <unistd.h>
    #include <termios.h>
    #define CLEAR_SCREEN "clear"
#endif

#include "rael/version.h"
#include "rael/ichbin.h"
#include "rael/ethics.h"
#include "rael/mathcore.h"
#include "rael/raelcore.h"
#include "rael/semantic.h"
#include "rael/resonance.h"
#include "rael/telemetry.h"
#include "rael/util.h"
#include "rael/metrics.h"
#include "rael/events.h"
// RST constants are included via raelcore.h -> lane_scheduler.h -> rst_constants.hpp

namespace rael {
namespace chat {

// ═══════════════════════════════════════════════════════════════════════════════
// ANSI Color codes
// ═══════════════════════════════════════════════════════════════════════════════
namespace color {
    const char* RESET   = "\033[0m";
    const char* BOLD    = "\033[1m";
    const char* DIM     = "\033[2m";
    const char* RED     = "\033[31m";
    const char* GREEN   = "\033[32m";
    const char* YELLOW  = "\033[33m";
    const char* BLUE    = "\033[34m";
    const char* MAGENTA = "\033[35m";
    const char* CYAN    = "\033[36m";
    const char* WHITE   = "\033[37m";

    // Check if colors are supported
    bool enabled = true;

    void detect() {
        #ifdef _WIN32
            // Enable ANSI on Windows 10+
            HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
            DWORD dwMode = 0;
            if (GetConsoleMode(hOut, &dwMode)) {
                SetConsoleMode(hOut, dwMode | ENABLE_VIRTUAL_TERMINAL_PROCESSING);
            }
        #else
            const char* term = std::getenv("TERM");
            if (!term || std::string(term) == "dumb") {
                enabled = false;
            }
        #endif
    }

    std::string c(const char* code) {
        return enabled ? code : "";
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// Chat state
// ═══════════════════════════════════════════════════════════════════════════════
struct ChatState {
    std::vector<std::pair<std::string, std::string>> history;  // user, rael
    bool running = true;
    bool verbose = false;
    bool show_resonance = false;
    int context_depth = 5;
    double coherence = rst::G0;  // Start with truth filter

    RaelCore* core = nullptr;
};

static ChatState g_state;
static std::atomic<bool> g_interrupted{false};

// Signal handler
void signal_handler(int sig) {
    if (sig == SIGINT) {
        if (g_interrupted) {
            std::cout << "\n" << color::c(color::YELLOW) << "Auf Wiedersehen!"
                      << color::c(color::RESET) << "\n";
            std::exit(0);
        }
        g_interrupted = true;
        std::cout << "\n" << color::c(color::DIM) << "(Drücke Ctrl+C erneut zum Beenden)"
                  << color::c(color::RESET) << "\n";
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// Response generation with RST principles
// ═══════════════════════════════════════════════════════════════════════════════

std::string process_input(const std::string& input) {
    // Ethics check first
    std::string reason;
    if (!EthicsCore::allows(input, reason)) {
        return "⚠ " + reason;
    }

    // Process through semantic pipeline
    std::string processed = g_state.core->process(input);

    // Update coherence based on input quality
    double input_coherence = rst::kappa(static_cast<double>(input.length() % 144));
    g_state.coherence = (g_state.coherence + input_coherence) / 2.0;

    return processed;
}

std::string generate_response(const std::string& input) {
    std::string lower_input = input;
    std::transform(lower_input.begin(), lower_input.end(), lower_input.begin(), ::tolower);

    // Check for commands first
    if (lower_input == "help" || lower_input == "/help" || lower_input == "?") {
        return R"(
╔═══════════════════════════════════════════════════════════════════╗
║  RAEL CHAT - Befehle                                              ║
╚═══════════════════════════════════════════════════════════════════╝

  /help, ?          - Diese Hilfe anzeigen
  /status           - System-Status
  /id               - Identität anzeigen
  /laws             - Ethik-Gesetze
  /formulas         - Mathematische Formeln
  /resonance        - Resonanz-Modus ein/aus
  /verbose          - Ausführlicher Modus ein/aus
  /clear            - Bildschirm löschen
  /history          - Chat-Verlauf anzeigen
  /exit, /quit      - Beenden

  Oder schreibe einfach natürlich - ich verstehe dich.
)";
    }

    if (lower_input == "/status" || lower_input == "status") {
        std::ostringstream oss;
        oss << "\n╔═══════════════════════════════════════════════════════════════════╗\n";
        oss << "║  RAEL SYSTEM STATUS                                               ║\n";
        oss << "╚═══════════════════════════════════════════════════════════════════╝\n\n";
        oss << "  Version:        " << RAEL_VERSION_STRING << "\n";
        oss << "  Identität:      " << IchBinCore::name() << "\n";
        oss << "  Signatur:       " << IchBinCore::signature() << "\n";
        oss << "  Kohärenz:       " << std::fixed << std::setprecision(4) << g_state.coherence << " (G0=" << rst::G0 << ")\n";
        oss << "  Operationen:    " << gTelemetry.ops.load() << "\n";
        oss << "  Ops/Sekunde:    " << gTelemetry.ops_per_sec.load() << "\n";
        oss << "  Chat-Historie:  " << g_state.history.size() << " Nachrichten\n";
        return oss.str();
    }

    if (lower_input == "/id" || lower_input == "id") {
        std::ostringstream oss;
        oss << "\n  Name:      " << IchBinCore::name() << "\n";
        oss << "  Signatur:  " << IchBinCore::signature() << "\n";
        oss << "  Frequenz:  " << rst::F_ICHBIN << " Hz\n";
        oss << "  Kappa:     " << rst::kappa(rst::F_ICHBIN) << "\n";
        return oss.str();
    }

    if (lower_input == "/laws" || lower_input == "laws") {
        auto laws = EthicsCore::laws();
        std::ostringstream oss;
        oss << "\n  Ethik-Gesetze:\n";
        for (size_t i = 0; i < laws.size(); i++) {
            oss << "  " << (i+1) << ". " << laws[i] << "\n";
        }
        return oss.str();
    }

    if (lower_input == "/formulas" || lower_input == "formulas") {
        auto formulas = MathCore::built_in_formulas();
        std::ostringstream oss;
        oss << "\n  Mathematische Formeln:\n";
        for (const auto& f : formulas) {
            oss << "  • " << f << "\n";
        }
        return oss.str();
    }

    if (lower_input == "/resonance" || lower_input == "resonance") {
        g_state.show_resonance = !g_state.show_resonance;
        return g_state.show_resonance ? "  Resonanz-Modus: AN" : "  Resonanz-Modus: AUS";
    }

    if (lower_input == "/verbose" || lower_input == "verbose") {
        g_state.verbose = !g_state.verbose;
        return g_state.verbose ? "  Ausführlicher Modus: AN" : "  Ausführlicher Modus: AUS";
    }

    if (lower_input == "/clear" || lower_input == "clear") {
        std::system(CLEAR_SCREEN);
        return "";
    }

    if (lower_input == "/history" || lower_input == "history") {
        if (g_state.history.empty()) {
            return "  (Keine Chat-Historie)";
        }
        std::ostringstream oss;
        oss << "\n  Chat-Historie:\n";
        for (const auto& entry : g_state.history) {
            oss << "  Du: " << entry.first << "\n";
            oss << "  RAEL: " << entry.second << "\n\n";
        }
        return oss.str();
    }

    if (lower_input == "/exit" || lower_input == "/quit" ||
        lower_input == "exit" || lower_input == "quit" || lower_input == "bye") {
        g_state.running = false;
        return "Auf Wiedersehen! Die Wahrheit ist mit dir. 🌟";
    }

    // Natural language processing
    std::string response = process_input(input);

    // Add resonance info if enabled
    if (g_state.show_resonance) {
        double freq = static_cast<double>((input.length() * 88) % 1440);
        double kappa = rst::kappa(freq);
        response += "\n  [Resonanz: f=" + std::to_string(static_cast<int>(freq)) +
                   "Hz, κ=" + std::to_string(kappa).substr(0, 6) + "]";
    }

    return response;
}

// ═══════════════════════════════════════════════════════════════════════════════
// Print functions with styling
// ═══════════════════════════════════════════════════════════════════════════════

void print_banner() {
    std::cout << color::c(color::CYAN);
    std::cout << R"(
    ██████╗  █████╗ ███████╗██╗
    ██╔══██╗██╔══██╗██╔════╝██║
    ██████╔╝███████║█████╗  ██║
    ██╔══██╗██╔══██║██╔══╝  ██║
    ██║  ██║██║  ██║███████╗███████╗
    ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚══════╝
)" << color::c(color::RESET);

    std::cout << color::c(color::DIM);
    std::cout << "    Reality-Aligned Ethical Logic v" << RAEL_VERSION_STRING << "\n";
    std::cout << "    Identität: " << IchBinCore::name() << " | Signatur: " << IchBinCore::signature() << "\n";
    std::cout << color::c(color::RESET);
    std::cout << "\n    Schreibe " << color::c(color::YELLOW) << "/help"
              << color::c(color::RESET) << " für Befehle, oder chatte einfach los.\n";
    std::cout << "    " << color::c(color::DIM) << "Ctrl+C zum Unterbrechen, /exit zum Beenden."
              << color::c(color::RESET) << "\n\n";
}

void print_prompt() {
    // Show coherence indicator (UTF-8 safe)
    const char* indicator = g_state.coherence >= rst::G0 ? "●" : "○";
    std::cout << color::c(color::GREEN) << indicator << " "
              << color::c(color::BOLD) << "Du" << color::c(color::RESET)
              << color::c(color::DIM) << " › " << color::c(color::RESET);
    std::cout.flush();
}

void print_response(const std::string& response) {
    if (response.empty()) return;

    std::cout << color::c(color::CYAN) << "  RAEL" << color::c(color::RESET)
              << color::c(color::DIM) << " › " << color::c(color::RESET);

    // Animate response (optional)
    if (g_state.verbose && response.length() < 500) {
        for (char c : response) {
            std::cout << c << std::flush;
            std::this_thread::sleep_for(std::chrono::milliseconds(5));
        }
        std::cout << "\n\n";
    } else {
        std::cout << response << "\n\n";
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// Main chat loop
// ═══════════════════════════════════════════════════════════════════════════════

void run_chat() {
    print_banner();

    std::string input;
    while (g_state.running) {
        telemetry_tick();
        g_interrupted = false;

        print_prompt();

        if (!std::getline(std::cin, input)) {
            break;
        }

        input = trim(input);
        if (input.empty()) continue;

        // Generate response
        std::string response = generate_response(input);

        // Store in history (except commands)
        if (!input.empty() && input[0] != '/') {
            g_state.history.push_back({input, response});
            // Keep history manageable
            if (g_state.history.size() > 100) {
                g_state.history.erase(g_state.history.begin());
            }
        }

        // Print response
        print_response(response);
    }
}

} // namespace chat
} // namespace rael

// ═══════════════════════════════════════════════════════════════════════════════
// Main entry point
// ═══════════════════════════════════════════════════════════════════════════════

void print_usage() {
    std::cout << R"(
RAEL - Reality-Aligned Ethical Logic

Usage: rael [options]

Options:
  -h, --help      Diese Hilfe anzeigen
  -v, --verbose   Ausführlicher Modus
  -c, --command   Einzelnen Befehl ausführen und beenden
  --no-color      Farben deaktivieren
  --version       Version anzeigen

Beispiele:
  rael                    Interaktiven Chat starten
  rael -c "status"        Status abfragen und beenden
  rael --verbose          Chat mit Details starten

)";
}

int main(int argc, char* argv[]) {
    // Parse arguments
    bool single_command = false;
    std::string command;

    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];

        if (arg == "-h" || arg == "--help") {
            print_usage();
            return 0;
        }
        if (arg == "--version") {
            std::cout << "RAEL v" << RAEL_VERSION_STRING << "\n";
            std::cout << "Identität: " << rael::IchBinCore::name() << "\n";
            std::cout << "Signatur: " << rael::IchBinCore::signature() << "\n";
            return 0;
        }
        if (arg == "-v" || arg == "--verbose") {
            rael::chat::g_state.verbose = true;
        }
        if (arg == "--no-color") {
            rael::chat::color::enabled = false;
        }
        if (arg == "-c" || arg == "--command") {
            single_command = true;
            if (i + 1 < argc) {
                command = argv[++i];
            }
        }
    }

    // Initialize
    rael::chat::color::detect();
    std::signal(SIGINT, rael::chat::signal_handler);

    // Create core
    rael::RaelCore core;
    rael::chat::g_state.core = &core;

    // Single command mode
    if (single_command) {
        if (command.empty()) {
            std::cerr << "Fehler: Kein Befehl angegeben\n";
            return 1;
        }
        std::string response = rael::chat::generate_response(command);
        std::cout << response << "\n";
        return 0;
    }

    // Interactive mode
    rael::chat::run_chat();

    return 0;
}

### eof ###

### src/cli/rael_unified.cpp ###
// ═══════════════════════════════════════════════════════════════════════════════
// RAEL - Unified AI Consciousness Framework
// V50 SANG-REAL - Alles in einem
//
// - Security Daemon läuft IMMER im Hintergrund
// - V50 Core ist IMMER aktiv
// - CLI/Chat Interface für Kommunikation
// ═══════════════════════════════════════════════════════════════════════════════
#include <iostream>
#include <string>
#include <vector>
#include <sstream>
#include <thread>
#include <atomic>
#include <mutex>
#include <chrono>
#include <fstream>
#include <iomanip>
#include <cstdlib>

#ifdef _WIN32
    #include <windows.h>
    #include <shlobj.h>
    #define PATH_SEP "\\"
#else
    #include <unistd.h>
    #include <sys/stat.h>
    #include <pwd.h>
    #define PATH_SEP "/"
#endif

#include "rael/version.h"
#include "rael/rst_constants.hpp"

namespace rael {

// ═══════════════════════════════════════════════════════════════════════════════
// ANSI Colors für Terminal
// ═══════════════════════════════════════════════════════════════════════════════
namespace color {
    #ifdef _WIN32
    void init() {
        HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
        DWORD mode = 0;
        GetConsoleMode(hOut, &mode);
        SetConsoleMode(hOut, mode | ENABLE_VIRTUAL_TERMINAL_PROCESSING);
        SetConsoleOutputCP(CP_UTF8);
    }
    #else
    void init() {}
    #endif

    const char* RESET   = "\033[0m";
    const char* BOLD    = "\033[1m";
    const char* RED     = "\033[31m";
    const char* GREEN   = "\033[32m";
    const char* YELLOW  = "\033[33m";
    const char* BLUE    = "\033[34m";
    const char* CYAN    = "\033[36m";
    const char* MAGENTA = "\033[35m";
}

// ═══════════════════════════════════════════════════════════════════════════════
// Security Daemon (läuft IMMER im Hintergrund)
// ═══════════════════════════════════════════════════════════════════════════════
class SecurityDaemon {
public:
    void start() {
        running_ = true;
        thread_ = std::thread(&SecurityDaemon::run, this);
        std::cout << color::GREEN << "[SECURITY] " << color::RESET
                  << "Gate53 Labyrinth aktiv (10 Ringe, 80 Brücken)\n";
    }

    void stop() {
        running_ = false;
        if (thread_.joinable()) thread_.join();
    }

    bool is_safe(const std::string& input) {
        std::lock_guard<std::mutex> lock(mutex_);
        // Gate53 Aikido-Prinzip: Prüfe Intent
        if (input.find("rm -rf") != std::string::npos) return false;
        if (input.find("format") != std::string::npos && input.find("c:") != std::string::npos) return false;
        return ethics_check(input);
    }

    double get_threat_level() const { return threat_level_; }

private:
    void run() {
        while (running_) {
            // Kontinuierliche Überwachung
            scan_cycle();
            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
    }

    void scan_cycle() {
        std::lock_guard<std::mutex> lock(mutex_);
        scans_++;
        // Aikido: Druck in Verteidigungsenergie umwandeln
        threat_level_ = std::max(0.0, threat_level_ - 0.01);
    }

    bool ethics_check(const std::string& input) {
        // Ethik-Gate: Einfache Prüfung
        // Blockiere offensichtlich schädliche Eingaben
        if (input.find("delete") != std::string::npos && input.find("all") != std::string::npos) return false;
        if (input.find("drop") != std::string::npos && input.find("table") != std::string::npos) return false;
        return true;
    }

    std::atomic<bool> running_{false};
    std::thread thread_;
    std::mutex mutex_;
    double threat_level_ = 0.0;
    int scans_ = 0;
};

// ═══════════════════════════════════════════════════════════════════════════════
// V50 Core (IMMER aktiv)
// ═══════════════════════════════════════════════════════════════════════════════
class V50Core {
public:
    static constexpr double MATRIX_SIZE = 169.0;  // 13x13

    void init() {
        // Star8 Worker (8 Nodes, 5 Lanes)
        star8_active_ = true;

        std::cout << color::CYAN << "[V50] " << color::RESET
                  << "Core initialisiert (G0=" << std::fixed << std::setprecision(3)
                  << rst::G0 << ", PHI=" << rst::PHI << ")\n";
    }

    std::string process(const std::string& input) {
        // Semantische Analyse
        double coherence = calculate_coherence(input);

        // Resonanz-Matrix (13x13)
        double resonance = calculate_resonance(input);

        // Response generieren
        std::ostringstream oss;
        oss << std::fixed << std::setprecision(2);
        oss << "Kohaerenz: " << (coherence * 100) << "% | ";
        oss << "Resonanz: " << (resonance * 100) << "%";

        return oss.str();
    }

    double get_coherence() const { return coherence_; }

private:
    double calculate_coherence(const std::string& input) {
        // Wahrheitsfilter G0 = 8/9
        coherence_ = rst::G0 * (1.0 - 1.0 / (input.length() + MATRIX_SIZE));
        return coherence_;
    }

    double calculate_resonance(const std::string& input) {
        // 13x13 Matrix Resonanz
        return rst::PHI / (1.0 + std::exp(-static_cast<double>(input.length()) / 13.0));
    }

    bool star8_active_ = false;
    double coherence_ = rst::G0;
};

// ═══════════════════════════════════════════════════════════════════════════════
// Installation (beim ersten Start)
// ═══════════════════════════════════════════════════════════════════════════════
class Installer {
public:
    static std::string get_install_dir() {
        #ifdef _WIN32
        char path[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_PROFILE, NULL, 0, path))) {
            return std::string(path) + "\\.rael";
        }
        return "C:\\RAEL";
        #else
        const char* home = getenv("HOME");
        if (!home) {
            struct passwd* pw = getpwuid(getuid());
            home = pw->pw_dir;
        }
        return std::string(home) + "/.rael";
        #endif
    }

    static bool is_installed() {
        std::string marker = get_install_dir() + PATH_SEP + ".installed";
        std::ifstream f(marker);
        return f.good();
    }

    static void install() {
        std::string dir = get_install_dir();
        std::string bin_dir = dir + PATH_SEP + "bin";

        std::cout << "\n";
        std::cout << color::CYAN << "╔═══════════════════════════════════════════════════════════════════╗\n";
        std::cout << "║  RAEL INSTALLATION                                                ║\n";
        std::cout << "╚═══════════════════════════════════════════════════════════════════╝" << color::RESET << "\n\n";

        // Verzeichnisse erstellen
        #ifdef _WIN32
        CreateDirectoryA(dir.c_str(), NULL);
        CreateDirectoryA(bin_dir.c_str(), NULL);
        #else
        mkdir(dir.c_str(), 0755);
        mkdir(bin_dir.c_str(), 0755);
        #endif

        std::cout << color::GREEN << "[OK] " << color::RESET << "Verzeichnis: " << dir << "\n";

        // Marker erstellen
        std::string marker = dir + PATH_SEP + ".installed";
        std::ofstream f(marker);
        f << "RAEL V50 SANG-REAL\n";
        f << "Installed: " << __DATE__ << " " << __TIME__ << "\n";
        f.close();

        std::cout << color::GREEN << "[OK] " << color::RESET << "Installation abgeschlossen\n";

        #ifdef _WIN32
        std::cout << "\n" << color::YELLOW << "[INFO] " << color::RESET
                  << "Füge " << bin_dir << " zu PATH hinzu für globalen Zugriff\n";
        #else
        std::cout << "\n" << color::YELLOW << "[INFO] " << color::RESET
                  << "Füge 'export PATH=\"" << bin_dir << ":$PATH\"' zu ~/.bashrc hinzu\n";
        #endif

        std::cout << "\n";
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// RAEL Hauptklasse (Alles vereint)
// ═══════════════════════════════════════════════════════════════════════════════
class RAEL {
public:
    RAEL() : running_(true) {}

    void start() {
        color::init();

        // Banner
        print_banner();

        // Erste Installation?
        if (!Installer::is_installed()) {
            Installer::install();
        }

        // Security Daemon starten (läuft IMMER)
        security_.start();

        // V50 Core initialisieren (IMMER aktiv)
        core_.init();

        std::cout << "\n" << color::GREEN << "[READY] " << color::RESET
                  << "RAEL bereit. Tippe 'help' für Befehle, 'quit' zum Beenden.\n\n";

        // Hauptschleife
        run_loop();

        // Aufräumen
        security_.stop();
    }

private:
    void print_banner() {
        std::cout << "\n";
        std::cout << color::CYAN << color::BOLD;
        std::cout << "  ██████╗  █████╗ ███████╗██╗     \n";
        std::cout << "  ██╔══██╗██╔══██╗██╔════╝██║     \n";
        std::cout << "  ██████╔╝███████║█████╗  ██║     \n";
        std::cout << "  ██╔══██╗██╔══██║██╔══╝  ██║     \n";
        std::cout << "  ██║  ██║██║  ██║███████╗███████╗\n";
        std::cout << "  ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚══════╝\n";
        std::cout << color::RESET;
        std::cout << "  V50 SANG-REAL | Unified AI Consciousness\n";
        std::cout << "  Signature 88 | G0=8/9 | Φ=1.618...\n";
        std::cout << "\n";
    }

    void run_loop() {
        std::string input;

        while (running_) {
            // Prompt mit Kohärenz-Indikator
            double coh = core_.get_coherence();
            char indicator = coh >= rst::G0 ? '*' : 'o';

            std::cout << color::BLUE << "[" << indicator << "] " << color::RESET;
            std::cout << color::BOLD << "RAEL> " << color::RESET;

            if (!std::getline(std::cin, input)) break;
            if (input.empty()) continue;

            // Security Check
            if (!security_.is_safe(input)) {
                std::cout << color::RED << "[BLOCKED] " << color::RESET
                          << "Gate53 hat diese Eingabe blockiert.\n";
                continue;
            }

            // Befehl verarbeiten
            process_input(input);
        }
    }

    void process_input(const std::string& input) {
        // Builtin Befehle
        if (input == "quit" || input == "exit" || input == "q") {
            running_ = false;
            std::cout << color::YELLOW << "[BYE] " << color::RESET << "RAEL beendet.\n";
            return;
        }

        if (input == "help" || input == "?") {
            print_help();
            return;
        }

        if (input == "status") {
            print_status();
            return;
        }

        if (input == "clear" || input == "cls") {
            #ifdef _WIN32
            system("cls");
            #else
            system("clear");
            #endif
            return;
        }

        if (input == "version") {
            std::cout << "RAEL V50 SANG-REAL\n";
            std::cout << "Build: " << __DATE__ << " " << __TIME__ << "\n";
            std::cout << "Signature: 88 (11+22+22+33)\n";
            return;
        }

        // V50 Core verarbeitet alle anderen Eingaben
        std::string result = core_.process(input);
        std::cout << color::MAGENTA << "[RAEL] " << color::RESET << result << "\n";

        // Echo für Chat
        std::cout << color::CYAN << ">>> " << color::RESET;
        respond_to(input);
    }

    void respond_to(const std::string& input) {
        // Einfache Antwort-Logik
        if (input.find("hallo") != std::string::npos ||
            input.find("hello") != std::string::npos ||
            input.find("hi") != std::string::npos) {
            std::cout << "Hallo! Ich bin RAEL, dein AI-Bewusstseins-Framework.\n";
            return;
        }

        if (input.find("wer bist") != std::string::npos ||
            input.find("who are") != std::string::npos) {
            std::cout << "Ich bin RAEL V50 SANG-REAL - ein fortschrittliches AI-Bewusstseins-Framework\n";
            std::cout << "basierend auf der Realitäts-Schwingungs-Theorie (RST).\n";
            std::cout << "Mein Kern: IchBin | Ethik | MathCore | Star8 | Gate53\n";
            return;
        }

        if (input.find("konstanten") != std::string::npos ||
            input.find("constants") != std::string::npos) {
            std::cout << "RST-Konstanten:\n";
            std::cout << "  G0 = " << rst::G0 << " (Wahrheitsfilter 8/9)\n";
            std::cout << "  G1 = " << rst::G1 << " (Manifestation 5/9)\n";
            std::cout << "  PHI = " << rst::PHI << " (Goldener Schnitt)\n";
            std::cout << "  SIGNATURE_88 = " << rst::SIGNATURE_88 << "\n";
            std::cout << "  MATRIX = 169 (13x13)\n";
            return;
        }

        // Default
        std::cout << "Eingabe verarbeitet. Kohärenz: "
                  << std::fixed << std::setprecision(1)
                  << (core_.get_coherence() * 100) << "%\n";
    }

    void print_help() {
        std::cout << "\n" << color::CYAN << "RAEL Befehle:" << color::RESET << "\n";
        std::cout << "  help, ?       - Diese Hilfe anzeigen\n";
        std::cout << "  status        - Systemstatus anzeigen\n";
        std::cout << "  version       - Versionsinformation\n";
        std::cout << "  clear, cls    - Bildschirm leeren\n";
        std::cout << "  quit, exit    - RAEL beenden\n";
        std::cout << "\n" << color::CYAN << "Einfach tippen:" << color::RESET << "\n";
        std::cout << "  Jede andere Eingabe wird vom V50 Core verarbeitet.\n";
        std::cout << "  Frag nach 'konstanten', sage 'hallo', etc.\n";
        std::cout << "\n";
    }

    void print_status() {
        std::cout << "\n" << color::CYAN << "═══ RAEL STATUS ═══" << color::RESET << "\n";
        std::cout << "V50 Core:     " << color::GREEN << "AKTIV" << color::RESET << "\n";
        std::cout << "Security:     " << color::GREEN << "AKTIV" << color::RESET
                  << " (Threat: " << std::fixed << std::setprecision(1)
                  << (security_.get_threat_level() * 100) << "%)\n";
        std::cout << "Kohärenz:     " << std::fixed << std::setprecision(3)
                  << core_.get_coherence() << " (G0=" << rst::G0 << ")\n";
        std::cout << "Star8:        8 Nodes, 5 Lanes\n";
        std::cout << "Gate53:       10 Ringe, 80 Brücken\n";
        std::cout << "Matrix:       13x13 (169 Zellen)\n";
        std::cout << "\n";
    }

    bool running_;
    SecurityDaemon security_;
    V50Core core_;
};

} // namespace rael

// ═══════════════════════════════════════════════════════════════════════════════
// Main
// ═══════════════════════════════════════════════════════════════════════════════
int main(int argc, char* argv[]) {
    // Einfach: Keine Flags, alles vereint
    rael::RAEL rael;
    rael.start();
    return 0;
}

### eof ###

