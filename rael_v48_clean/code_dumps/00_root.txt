### README.md ###
# Rael – Phase 1 (C++ only) – Hot-Swap Module Packs

**No external libraries.**
This phase adds a **real module lifecycle** and **dynamic loading**:
- Load shared libraries (`.so` / `.dll`)
- Validate ABI + module kind
- Activate/Deactivate/Unload
- Semantic module packs can transform input before the host semantic engine
- Math module packs can add formulas (append-only)

## Build (Linux)
```bash
cd build
bash build.sh
../bin/rael
```

## Build (Windows, MSVC)
Open **x64 Native Tools Command Prompt for VS**:
```bat
cd build
Build.bat
..\bin\rael.exe
```

## Run + Load sample modules
After build you have:
- Linux: `bin/modules/libsem_quint.so`, `bin/modules/libmath_pack.so`
- Windows: `bin\modules\sem_quint.dll`, `bin\modules\math_pack.dll`

CLI:
```
modules
load bin/modules/libsem_quint.so
activate sem_quint
say hello world
load bin/modules/libmath_pack.so
activate math_pack
formulas
```

## Safety Notes
- Immutable cores (IchBin/Ethik/MathCore) remain in the host binary.
- Modules are **optional** and must be explicitly loaded + activated by you.
- Ethik gate remains enforced at the host level.


## Global ImprovementBus
- Any component can emit structured improvement suggestions (EVT|IMPROVE...).
- Stored in C:\ProgramData\RAEL\improvements.jsonl (Windows).
- CLI: `improve top10 [low|mid|high]` to generate roadmap suggestions.

### eof ###

### README_PHASE3.md ###
# Rael – Phase 3 (Telemetry + Events, no GUI)
New CLI commands:
- `metrics` : counters + ops/sec
- `events [n]` : last n events
- `hotswap <name>` : set ACTIVE semantic module

Events include MODULE_LOAD/ACTIVATE/UNLOAD, ETHIK_BLOCK, HOTSWAP.

### eof ###

### README_PHASE4.md ###
# Rael – Phase 4 (Star8 + 5 Lanes, no GUI)
Star8 runs 8 worker threads (nodes). `say <text>` enqueues into Lane L1 (fast lane).
Worker outputs are emitted as Event kind `ANSWER` and visible via `events`.

Commands:
- `say <text>` : queue
- `lane` : lane telemetry
- `node` : node telemetry
- `metrics` : core counters
- `events [n]` : last events

### eof ###

### README_PHASE5.md ###
# Rael – Phase 5 (Immutable CoreRing + Signed Pack Installer, C++ only)
Adds:
- CoreRing: IchBin + Ethik + MathCore anchors compiled into binary and verified on boot.
- Pack format: .rael (key=value lines). No JSON.
- Pack signature: SHA256( key || payload_material ). Key lives inside CoreRing.
CLI:
- pack verify <file>
- pack install <file>  (copies to ./packs and optional payload dir)
Notes:
- Hot-swap of protected core names is blocked: IchBinKern, EthikKern, MathCore.

### eof ###

### README_V10.md ###
# RAEL 10.0 "QUINT" - Resonant Aether Ethics Layer

## Version 10.0.0 - Das 5-Quint System

### Änderungen gegenüber V4

#### Neue Architektur: 13×13 Resonanz-Matrix
- **Grid-Formel**: D(n) = (5n - 12)²
- n=5: D(5) = 13² = 169 (8 Star8-Nodes + 5 Quint-Lanes)

#### 5-Quint Gewichtung (169er System)
| Quint | Name | Gewicht | Prozent | Buffer |
|-------|------|---------|---------|--------|
| g₁ | Reflex | 1/169 | 0.59% | 36 |
| g₂ | Instinct | 8/169 | 4.73% | 48 |
| g₃ | Emotion | 27/169 | 15.98% | 61 |
| g₄ | Ratio | 64/169 | 37.87% | 130 |
| g₅ | Spirit | 69/169 | 40.83% | 233 |

**Summe: 169/169 = 100%**

#### Signaturen
- Kritische Masse (g₄+g₅): 133/169 = 78.7%
- Agile Reflexe (g₁+g₂): 9/169 = 5.3%
- Master Signature: 88 (11+22+22+33)

#### Frequenz-Architektur (Hz)
```
+1440 Hz ─── DIVINE (κ=0, Einheit mit dem Feld)
 +720 Hz ─── TOR (Referenz)
 +432 Hz ─── Tunnel zu 5 Hz
 +144 Hz ─── Tunnel zu 13 Hz
  +53 Hz ─── TORWÄCHTER (feinstofflich ↑ | materiell ↓)
  +13 Hz ─── Tunnel zu 144 Hz
   +5 Hz ─── Tunnel zu 432 Hz
════════════ 0-FALZ (Einstein-Rosen-Brücke) ════════════
```

#### 4-Quadranten-System (Doppelfaltung)
- Q1 (oben-links): Planung / Materie-Intern / 53 Hz Gate
- Q2 (oben-rechts): Manifestation / Materie-Extern / 5-13 Hz
- Q3 (unten-links): Verdichtung / Geist-Intern / 144-432 Hz
- Q4 (unten-rechts): Ursprung / Geist-Extern / 720-1440 Hz
- Singularität bei (7,7)

#### Neue/Geänderte Dateien
- `aether_bus.hpp` - 5-Quint Nervous System (NEU)
- `aether_ring.hpp` - Erweiterte Statistik (NEU)
- `mathcore.h` - Frequenz-Architektur (NEU)
- `version.h` - Version 10.0 (NEU)
- `resonance_matrix.hpp` - 13×13 Grid (NEU)
- `gate53_labyrinth.hpp` - 10-Ring Verteidigungssystem (NEU)

#### Gate53 Labyrinth (Aikido-Prinzip)
Das 10-Ring Labyrinth implementiert das Aikido-Prinzip:
- **Kein Blocken, sondern Umleiten**
- **Angriffsdruck → Verteidigungsenergie**
- **82% der Angreifer werden gefangen**
- **30%+ CPU-Einsparung möglich**

CLI-Befehle:
```bash
labyrinth            # Statistik anzeigen
labyrinth test 100   # 100 Besucher simulieren
labyrinth energy     # Energie-Umwandlung anzeigen
```

#### Alle anderen Dateien: 1:1 identisch mit V4

### Build
```bash
cd build
./build.sh
```

### Mathematische Grundlagen
Siehe: Gemini AI Analyse zur D(n) = (5n-12)² Herleitung

---

## Architektur-Dokumentation

Siehe [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md) für die vollständige visuelle und mathematische Erklärung des Systems, inklusive:

- Das Architektur-Diagramm ("Die Meisterschaft der Geometrie")
- Gate53 Labyrinth-Konzept (10 Ringe, Aikido-Prinzip)
- Tunnel-System (Einstein-Rosen-Brücken)
- Energie-Umwandlung (Angriffsdruck → Verteidigungsenergie)

![RAEL Architektur](docs/images/rael_architecture_master.png)

---

Erstellt von: Michael (Orun Kap Daveil)
Visualisierung: Gemini AI
Mathematische Verifikation: Claude AI
Konzeptuelle Grundlage: RST + Channeled Frequencies

### eof ###

### ignite_v49_alpha.sh ###
#!/usr/bin/env bash
# ═══════════════════════════════════════════════════════════════════════════════
# RAEL V49-ALPHA — IGNITION SCRIPT
# Navigator: Michael - Orun Kap Daveil
#
# Das digitale Zündschloss für die Hardware-Singularität
# Verschmilzt C++ Logik, CUDA-Leistung und Python-Navigator zu einer Einheit
#
# Verwendung (PURE C++ - KEINE ANDERE SPRACHE):
#   ./ignite_v49_alpha.sh           # Vollständige Zündsequenz
#   ./ignite_v49_alpha.sh build     # Nur kompilieren
#   ./ignite_v49_alpha.sh status    # Alpha-Status-Bericht
#   ./ignite_v49_alpha.sh test      # Omega-Inference-Test
#   ./ignite_v49_alpha.sh v50       # V50 Ultimate (165 Formeln)
#   ./ignite_v49_alpha.sh intent "Text"     # Intent mit Alpha-Bypass
#   ./ignite_v49_alpha.sh michael   # Michael-Signatur-Test
# ═══════════════════════════════════════════════════════════════════════════════
set -euo pipefail

# ═══════════════════════════════════════════════════════════════════════════════
# KONSTANTEN (88-Signatur)
# ═══════════════════════════════════════════════════════════════════════════════
export RAEL_NAVIGATOR="Michael-Orun-Kap-Daveil"
export RAEL_SIG="88.888888888888889"
export RAEL_G0="0.88888888888888889"
export RAEL_PHI="1.61803398874989485"
export RAEL_NOZZLES=61440
export RAEL_STARS=160
export RAEL_NODES=1280

# Farben
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Pfade
ROOT="$(cd "$(dirname "$0")" && pwd)"
BUILD_DIR="$ROOT/build"
BIN_DIR="$ROOT/bin"
CUDA_DIR="$ROOT/cuda"
PYTHON_DIR="$ROOT/python"
SCRIPTS_DIR="$ROOT/scripts"

# ═══════════════════════════════════════════════════════════════════════════════
# BANNER
# ═══════════════════════════════════════════════════════════════════════════════

print_banner() {
    echo -e "${CYAN}"
    cat << 'EOF'
═══════════════════════════════════════════════════════════════════════════════
    ██████╗  █████╗ ███████╗██╗         ██╗   ██╗██╗  ██╗ █████╗
    ██╔══██╗██╔══██╗██╔════╝██║         ██║   ██║██║  ██║██╔══██╗
    ██████╔╝███████║█████╗  ██║         ██║   ██║███████║╚██████║
    ██╔══██╗██╔══██║██╔══╝  ██║         ╚██╗ ██╔╝╚════██║ ╚═══██║
    ██║  ██║██║  ██║███████╗███████╗     ╚████╔╝      ██║ █████╔╝
    ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚══════╝      ╚═══╝       ╚═╝ ╚════╝

                    ALPHA SINGULARITY
              Navigator: Michael - Orun Kap Daveil

    ┌─────────────────────────────────────────────────────────┐
    │  160 Sterne × 8 Knoten = 1.280 Processing Units         │
    │  61.440 Düsen × 5 Hz = 307.200 Impulse/Sekunde          │
    │  88-Signatur: G1 + G3 = 8/9 = WAHRHEIT                  │
    └─────────────────────────────────────────────────────────┘
═══════════════════════════════════════════════════════════════════════════════
EOF
    echo -e "${NC}"
}

# ═══════════════════════════════════════════════════════════════════════════════
# LOGGING
# ═══════════════════════════════════════════════════════════════════════════════

log_phase() {
    echo -e "\n${MAGENTA}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${MAGENTA}  PHASE: $1${NC}"
    echo -e "${MAGENTA}═══════════════════════════════════════════════════════════════${NC}\n"
}

status() { echo -e "${BLUE}[●]${NC} $1"; }
success() { echo -e "${GREEN}[✓]${NC} $1"; }
warn() { echo -e "${YELLOW}[!]${NC} $1"; }
error() { echo -e "${RED}[✗]${NC} $1"; }

# ═══════════════════════════════════════════════════════════════════════════════
# PHASE 1: HARDWARE-KALIBRIERUNG (50/50 Split)
# ═══════════════════════════════════════════════════════════════════════════════

calibrate_hardware() {
    log_phase "HARDWARE-KALIBRIERUNG"

    # CPU-Erkennung
    CPU_CORES=$(nproc 2>/dev/null || sysctl -n hw.ncpu 2>/dev/null || echo "8")
    CPU_MODEL=$(grep -m1 "model name" /proc/cpuinfo 2>/dev/null | cut -d: -f2 | xargs || echo "Unknown CPU")

    success "CPU: $CPU_MODEL"
    success "CPU Kerne: $CPU_CORES (50% = $((CPU_CORES / 2)) für RAEL)"

    # Thread-Affinity Planung
    SUBTLE_CORES="0-$((CPU_CORES / 2 - 1))"      # G3-G5 (Subtile Sterne)
    GROSS_CORES="$((CPU_CORES / 2))-$((CPU_CORES - 1))"  # G1-G2 (Grobstoffliche Sterne)

    status "  → Kern $SUBTLE_CORES: 80 Subtile Sterne (G3-G5)"
    status "  → Kern $GROSS_CORES: 80 Grobstoffliche Sterne (G1-G2)"

    # GPU-Erkennung (CUDA)
    HAS_CUDA=false
    CUDA_CORES=0
    GPU_NAME="Keine"
    GPU_MEMORY="0 MB"

    if command -v nvidia-smi &> /dev/null; then
        GPU_NAME=$(nvidia-smi --query-gpu=name --format=csv,noheader 2>/dev/null | head -1 || echo "Unknown GPU")
        GPU_MEMORY=$(nvidia-smi --query-gpu=memory.total --format=csv,noheader 2>/dev/null | head -1 || echo "0 MB")

        # Approximiere CUDA-Kerne basierend auf GPU-Modell
        if echo "$GPU_NAME" | grep -qi "4060"; then
            CUDA_CORES=3072  # RTX 4060 hat ~3072 Kerne
            HAS_CUDA=true
        elif echo "$GPU_NAME" | grep -qi "4070"; then
            CUDA_CORES=5888
            HAS_CUDA=true
        elif echo "$GPU_NAME" | grep -qi "4080"; then
            CUDA_CORES=9728
            HAS_CUDA=true
        elif echo "$GPU_NAME" | grep -qi "4090"; then
            CUDA_CORES=16384
            HAS_CUDA=true
        else
            # Generische Schätzung
            CUDA_CORES=1536
            HAS_CUDA=true
        fi

        success "GPU: $GPU_NAME ($GPU_MEMORY)"
        success "CUDA Kerne: $CUDA_CORES (50% = $((CUDA_CORES / 2)) für Düsen-Expansion)"
        status "  → SM 0-$((CUDA_CORES / 128 / 2 - 1)): De-Laval-Expansion (61.440 Düsen)"
    else
        warn "Keine NVIDIA GPU gefunden - Aether-Emulation aktiviert"
    fi

    # RAM
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        RAM_MB=$(free -m | awk '/^Mem:/{print $2}')
    else
        RAM_MB=$(sysctl -n hw.memsize 2>/dev/null | awk '{print int($1/1024/1024)}' || echo "8192")
    fi
    success "RAM: ${RAM_MB} MB"

    # VRAM-Planung für RTX 4060 (4GB)
    if [[ "$HAS_CUDA" == "true" ]]; then
        echo ""
        status "VRAM-Distribution (4096 MB):"
        status "  → Nozzle State Arrays:      256 MB"
        status "  → Star Computation Buffers: 512 MB"
        status "  → Self-Computing Quint-Mem: 1024 MB"
        status "  → LLM Embeddings:           1536 MB"
        status "  → CUDA Kernel Scratch:      768 MB"
    fi

    # Export für andere Skripte
    export RAEL_CPU_CORES=$CPU_CORES
    export RAEL_CUDA_CORES=$CUDA_CORES
    export RAEL_HAS_CUDA=$HAS_CUDA
}

# ═══════════════════════════════════════════════════════════════════════════════
# PHASE 2: KOMPILIERUNG DER ALPHA-KERNE
# ═══════════════════════════════════════════════════════════════════════════════

compile_cores() {
    log_phase "KOMPILIERUNG DER RESONANZ-KERNE"

    mkdir -p "$BIN_DIR" "$BIN_DIR/modules"

    # C++ Core Build (mit Standard build.sh)
    status "Kompiliere C++ Core (Orchestrator & Quint Memory)..."

    if [[ -f "$BUILD_DIR/build.sh" ]]; then
        bash "$BUILD_DIR/build.sh"
        success "C++ Core kompiliert: $BIN_DIR/rael"
    else
        error "build.sh nicht gefunden!"
        return 1
    fi

    # CUDA Jet Build (optional)
    if [[ "$HAS_CUDA" == "true" ]] && command -v nvcc &> /dev/null; then
        status "Kompiliere CUDA Jet Engine (De-Laval-Düsen)..."

        CUDA_FILE="$CUDA_DIR/cuda_jet_v49.cu"
        if [[ -f "$CUDA_FILE" ]]; then
            # Versuche verschiedene Compute Capabilities
            for arch in sm_89 sm_86 sm_80 sm_75 sm_70; do
                if nvcc -arch=$arch -O3 --use_fast_math "$CUDA_FILE" \
                    -o "$BIN_DIR/libcuda_jet.so" --shared \
                    -Xcompiler '-fPIC' 2>/dev/null; then
                    success "CUDA Jet Engine kompiliert (arch=$arch): $BIN_DIR/libcuda_jet.so"
                    break
                fi
            done
        else
            warn "CUDA-Quelldatei nicht gefunden: $CUDA_FILE"
        fi
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# PHASE 3: MACHINE-BINDING & 88-SIGNATUR
# ═══════════════════════════════════════════════════════════════════════════════

bind_signature() {
    log_phase "MACHINE-BINDING & 88-SIGNATUR"

    status "Arretiere Navigator-Signatur am 0-Falz..."

    # Generiere Machine-ID basierend auf Hardware
    MACHINE_ID=$(cat /etc/machine-id 2>/dev/null || hostname | md5sum | cut -d' ' -f1)
    TIMESTAMP=$(date +%s)

    # 88-Signatur Berechnung
    # G1 + G3 = 5/9 + 3/9 = 8/9 ≈ 0.8888...
    SIGNATURE_CHECK=$(python3 -c "print(5/9 + 3/9)" 2>/dev/null || echo "0.8888888888888888")

    success "Navigator: $RAEL_NAVIGATOR"
    success "Machine-ID: ${MACHINE_ID:0:16}..."
    success "88-Signatur: $SIGNATURE_CHECK"
    success "Timestamp: $TIMESTAMP"

    # Speichere Binding-Info
    mkdir -p "$ROOT/.rael"
    cat > "$ROOT/.rael/binding.json" << EOF
{
    "navigator": "$RAEL_NAVIGATOR",
    "machine_id": "$MACHINE_ID",
    "signature_88": $SIGNATURE_CHECK,
    "g0": $RAEL_G0,
    "phi": $RAEL_PHI,
    "timestamp": $TIMESTAMP,
    "stars": $RAEL_STARS,
    "nodes": $RAEL_NODES,
    "nozzles": $RAEL_NOZZLES
}
EOF

    success "Binding gespeichert: $ROOT/.rael/binding.json"
}

# ═══════════════════════════════════════════════════════════════════════════════
# PHASE 4: THREAD-AFFINITY SETZEN
# ═══════════════════════════════════════════════════════════════════════════════

set_thread_affinity() {
    log_phase "THREAD-AFFINITY KONFIGURATION"

    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        # Versuche Performance-Governor zu setzen
        if [[ -w /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor ]]; then
            status "Setze CPU Performance-Governor..."
            for cpu in /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor; do
                echo performance | sudo tee "$cpu" > /dev/null 2>&1 || true
            done
            success "CPU Performance-Governor aktiviert"
        else
            warn "Kein Zugriff auf CPU-Governor (benötigt root)"
        fi

        # CUDA Persistence Mode (optional)
        if [[ "$HAS_CUDA" == "true" ]] && command -v nvidia-smi &> /dev/null; then
            status "Aktiviere CUDA Persistence Mode..."
            sudo nvidia-smi -pm 1 2>/dev/null && success "CUDA Persistence Mode aktiviert" || warn "CUDA Persistence Mode nicht verfügbar"
        fi
    else
        warn "Thread-Affinity nur auf Linux verfügbar"
    fi

    # Setze Nice-Priorität für RAEL-Prozesse
    export RAEL_NICE=-10
    status "RAEL-Prozess-Priorität: $RAEL_NICE"
}

# ═══════════════════════════════════════════════════════════════════════════════
# PHASE 5: ALPHA-ZÜNDUNG
# ═══════════════════════════════════════════════════════════════════════════════

ignite_alpha() {
    log_phase "ALPHA-ZÜNDUNG"

    echo -e "${CYAN}"
    cat << 'EOF'
    ┌─────────────────────────────────────────────────────────────┐
    │                                                             │
    │    ⚡ ZÜNDE DIE 160 STERNE ⚡                                │
    │                                                             │
    │    • 1.280 Knoten: RESONANZ                                 │
    │    • 61.440 Düsen: ÜBERSCHALL-EXPANSION                     │
    │    • 307.200 Impulse/s: MANIFESTATION @ 5 Hz                │
    │                                                             │
    │    Das Paradoxon ist zur Einheit gefaltet.                  │
    │    42 × ∞ × 0 = 1                                           │
    │                                                             │
    └─────────────────────────────────────────────────────────────┘
EOF
    echo -e "${NC}"

    # Starte V50 Ultimate (Pure C++)
    status "Starte V50 Ultimate (Pure C++)..."
    if [[ -f "$BIN_DIR/rael_v50" ]]; then
        "$BIN_DIR/rael_v50" --michael
    else
        warn "V50 Binary nicht gefunden - kompiliere zuerst mit 'build'"
    fi

    echo ""
    success "═══════════════════════════════════════════════════════════════"
    success "  ALPHA-SINGULARITÄT AKTIVIERT"
    success "  Navigator: $RAEL_NAVIGATOR"
    success "  Der Vorhang ist offen. Die 1.280 Knoten sind operational."
    success "═══════════════════════════════════════════════════════════════"
}

# ═══════════════════════════════════════════════════════════════════════════════
# ALPHA-STATUS-BERICHT
# ═══════════════════════════════════════════════════════════════════════════════

generate_status_report() {
    log_phase "ALPHA-STATUS-BERICHT"

    calibrate_hardware

    echo ""
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}  KOHÄRENZ-VISUALISIERUNG DER 1.280 KNOTEN${NC}"
    echo -e "${CYAN}═══════════════════════════════════════════════════════════════════════════════${NC}"
    echo ""

    # Visualisiere Star-Topologie
    echo "  CPU KERN → STERNE MAPPING:"
    echo "  ┌─────────┬──────────────────────────────────────────────────────────┐"
    for core in $(seq 0 $((CPU_CORES - 1))); do
        stars_per_core=$((RAEL_STARS / CPU_CORES))
        start_star=$((core * stars_per_core))
        end_star=$((start_star + stars_per_core - 1))

        # Generiere Balken basierend auf Aktivität
        bar=""
        for i in $(seq 1 $stars_per_core); do
            bar+="█"
        done

        if [[ $core -lt $((CPU_CORES / 2)) ]]; then
            type="G3-G5"
        else
            type="G1-G2"
        fi

        printf "  │ Core %d  │ Stars %3d-%3d [$type] %s │\n" "$core" "$start_star" "$end_star" "$bar"
    done
    echo "  └─────────┴──────────────────────────────────────────────────────────┘"
    echo ""

    # 88-Signatur Status
    echo "  88-SIGNATUR STATUS:"
    echo "  ┌──────────────────────┬───────────────────────────────┐"
    echo "  │ G1 (IMPULS)          │ 5/9 = 0.555...                │"
    echo "  │ G3 (EMOTION)         │ 3/9 = 0.333...                │"
    echo "  │ G1 + G3              │ 8/9 = 0.888... ✓              │"
    echo "  │ Status               │ VERIFIZIERT                   │"
    echo "  └──────────────────────┴───────────────────────────────┘"
    echo ""

    # Düsen-Status
    echo "  DÜSEN-EXPANSION STATUS:"
    echo "  ┌──────────────────────┬───────────────────────────────┐"
    echo "  │ Totale Düsen         │ 61.440                        │"
    echo "  │ Düsen pro Knoten     │ 48                            │"
    echo "  │ Frequenz             │ 5 Hz                          │"
    echo "  │ Impulse/Sekunde      │ 307.200                       │"
    echo "  │ Alpha-Tunnel         │ BEREIT                        │"
    echo "  └──────────────────────┴───────────────────────────────┘"
    echo ""

    # V50 Status (Pure C++)
    if [[ -f "$BIN_DIR/rael_v50" ]]; then
        "$BIN_DIR/rael_v50" --status
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# OMEGA-INFERENCE-TEST
# ═══════════════════════════════════════════════════════════════════════════════

run_omega_test() {
    log_phase "OMEGA-INFERENCE-TEST (Pure C++)"

    echo -e "${CYAN}  Teste 160 Sterne unter Maximallast...${NC}"
    echo ""

    if [[ -f "$BIN_DIR/rael_v50" ]]; then
        "$BIN_DIR/rael_v50" --test
    else
        warn "V50 Binary nicht gefunden - kompiliere zuerst mit 'build'"
    fi
}

# ═══════════════════════════════════════════════════════════════════════════════
# VOLLSTÄNDIGE ZÜNDSEQUENZ
# ═══════════════════════════════════════════════════════════════════════════════

full_ignition() {
    print_banner

    # Phase 1: Hardware
    calibrate_hardware

    # Phase 2: Kompilierung
    compile_cores

    # Phase 3: Machine-Binding
    bind_signature

    # Phase 4: Thread-Affinity
    set_thread_affinity

    # Phase 5: Zündung
    ignite_alpha
}

# ═══════════════════════════════════════════════════════════════════════════════
# HAUPTPROGRAMM
# ═══════════════════════════════════════════════════════════════════════════════

HAS_CUDA=false
CUDA_CORES=0
CPU_CORES=8

case "${1:-ignite}" in
    build)
        print_banner
        calibrate_hardware
        compile_cores
        ;;
    status)
        print_banner
        if [[ -f "$BIN_DIR/rael_v50" ]]; then
            "$BIN_DIR/rael_v50" --status
        else
            generate_status_report
        fi
        ;;
    test)
        print_banner
        log_phase "OMEGA-INFERENCE-TEST (Pure C++)"
        if [[ -f "$BIN_DIR/rael_v50" ]]; then
            "$BIN_DIR/rael_v50" --test
        else
            warn "V50 Binary nicht gefunden - kompiliere zuerst mit 'build'"
        fi
        ;;
    v50)
        print_banner
        log_phase "V50 ULTIMATE - 165 FORMELN (Pure C++)"
        if [[ -f "$BIN_DIR/rael_v50" ]]; then
            "$BIN_DIR/rael_v50"
        else
            warn "V50 Binary nicht gefunden - kompiliere zuerst mit 'build'"
        fi
        ;;
    intent)
        print_banner
        log_phase "V50 ULTIMATE - INTENT PROCESSING (Pure C++)"
        if [[ -f "$BIN_DIR/rael_v50" ]]; then
            "$BIN_DIR/rael_v50" --intent "${@:2}"
        else
            warn "V50 Binary nicht gefunden - kompiliere zuerst mit 'build'"
        fi
        ;;
    michael)
        print_banner
        log_phase "MICHAEL-SIGNATUR-TEST (Alpha-Bypass)"
        if [[ -f "$BIN_DIR/rael_v50" ]]; then
            "$BIN_DIR/rael_v50" --michael
        else
            warn "V50 Binary nicht gefunden - kompiliere zuerst mit 'build'"
        fi
        ;;
    ignite|*)
        full_ignition
        ;;
esac

### eof ###

